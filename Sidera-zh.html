<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- 修复 #3: 防止 Safari 在输入框聚焦时自动缩放页面 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sidera</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjQwMCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+DQogICAgPCEtLSDlnIblvaLog4zmma/oibIgLS0+DQogICAgPGNpcmNsZSBjeD0iMjAwIiBjeT0iMjAwIiByPSIyMDAiIGZpbGw9IiMxMDE4MjEiIC8+DQogICAgDQogICAgPCEtLSDlha3ovrnlvaLkv53mjIHkuI3lj5ggLSDmtYXngbDoibIgLS0+DQogICAgPGcgaWQ9Im91dGVyLW1vbGVjdWxlIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDAsIDIwMCkiPg0KICAgICAgICA8cG9seWdvbiBwb2ludHM9IjExMi41OCw2NSAwLDEzMCAtMTEyLjU4LDY1IC0xMTIuNTgsLTY1IDAsLTEzMCAxMTIuNTgsLTY1IiBmaWxsPSJub25lIiBzdHJva2U9IiNBQUFBQUEiIHN0cm9rZS13aWR0aD0iMjUiPjwvcG9seWdvbj4NCiAgICA8L2c+DQoNCiAgICA8IS0tIOi/nuaOpeS4reW/g+WchuWSjOWkluWbtOWchueahOWFreadoee6vyAtLT4NCiAgICA8ZyBpZD0iY29ubmVjdGluZy1saW5lcyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjAwLCAyMDApIj4NCiAgICAgICAgPGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMTAzLjkiIHkyPSI2MCIgc3Ryb2tlPSIjRkZBNTAwIiBzdHJva2Utd2lkdGg9IjIwIj48L2xpbmU+DQogICAgICAgIDxsaW5lIHgxPSIwIiB5MT0iMCIgeDI9IjAiIHkyPSIxMjAiIHN0cm9rZT0iI0ZGQTUwMCIgc3Ryb2tlLXdpZHRoPSIyMCI+PC9saW5lPg0KICAgICAgICA8bGluZSB4MT0iMCIgeTE9IjAiIHgyPSItMTAzLjkiIHkyPSI2MCIgc3Ryb2tlPSIjRkZBNTAwIiBzdHJva2Utd2lkdGg9IjIwIj48L2xpbmU+DQogICAgICAgIDxsaW5lIHgxPSIwIiB5MT0iMCIgeDI9Ii0xMDMuOSIgeTI9Ii02MCIgc3Ryb2tlPSIjRkZBNTAwIiBzdHJva2Utd2lkdGg9IjIwIj48L2xpbmU+DQogICAgICAgIDxsaW5lIHgxPSIwIiB5MT0iMCIgeDI9IjAiIHkyPSItMTIwIiBzdHJva2U9IiNGRkE1MDAiIHN0cm9rZS13aWR0aD0iMjAiPjwvbGluZT4NCiAgICAgICAgPGxpbmUgeDE9IjAiIHkxPSIwIiB4Mj0iMTAzLjkiIHkyPSItNjAiIHN0cm9rZT0iI0ZGQTUwMCIgc3Ryb2tlLXdpZHRoPSIyMCI+PC9saW5lPg0KICAgIDwvZz4NCg0KICAgIDwhLS0g5YWt5Liq5a6e5b+D5ZyG5ZCR5Lit5b+D6Z2g5ouiIC0g5rWF54Gw6ImyIC0tPg0KICAgIDxnIGlkPSJvdXRlci1jaXJjbGVzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDAsIDIwMCkiPg0KICAgICAgICA8Y2lyY2xlIGN4PSIxMDMuOSIgY3k9IjYwIiByPSIzOCIgZmlsbD0iI0NDQ0NDQyI+PC9jaXJjbGU+DQogICAgICAgIDxjaXJjbGUgY3g9IjAiIGN5PSIxMjAiIHI9IjM4IiBmaWxsPSIjQ0NDQ0NDIj48L2NpcmNsZT4NCiAgICAgICAgPGNpcmNsZSBjeD0iLTEwMy45IiBjeT0iNjAiIHI9IjM4IiBmaWxsPSIjQ0NDQ0NDIj48L2NpcmNsZT4NCiAgICAgICAgPGNpcmNsZSBjeD0iLTEwMy45IiBjeT0iLTYwIiByPSIzOCIgZmlsbD0iI0NDQ0NDQyI+PC9jaXJjbGU+DQogICAgICAgIDxjaXJjbGUgY3g9IjAiIGN5PSItMTIwIiByPSIzOCIgZmlsbD0iI0NDQ0NDQyI+PC9jaXJjbGU+DQogICAgICAgIDxjaXJjbGUgY3g9IjEwMy45IiBjeT0iLTYwIiByPSIzOCIgZmlsbD0iI0NDQ0NDQyI+PC9jaXJjbGU+DQogICAgPC9nPg0KICAgIA0KICAgIDwhLS0g5Lit5b+D5ZyGIC0g5LiN5bqU55So5ruk6ZWcIC0tPg0KICAgIDxjaXJjbGUgY3g9IjIwMCIgY3k9IjIwMCIgcj0iMzgiIGZpbGw9IiNGRkQ3MDAiPjwvY2lyY2xlPg0KPC9zdmc+" type="image/x-icon"/>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0d1117;
            color: #c9d1d9;
            font-family: -apple-system, BlinkMacFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        #graph-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            background-color: #0d1117;
            /* 适配触控操作 */
            touch-action: none;
            /* 修复 #2: 移除移动端点击时的蓝色高亮框 */
            -webkit-tap-highlight-color: transparent;
        }

        /* --- 修改 START: 搜索框样式 --- */
        #search-container {
            position: fixed;
            top: 20px;
            left: 20px;
            transform: none; /* 改为左对齐 */
            /* 新增：添加最大宽度以避免与右侧按钮重叠 */
            max-width: calc(100% - 140px);
            z-index: 100;
            display: flex;
            gap: 8px;
            background-color: rgba(30, 30, 30, 0.8);
            /* 修改：移除边框 */
            border: none;
            padding: 8px;
            border-radius: 99px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        /* 新增：当侧边栏打开时隐藏搜索框 */
        body.sidebar-open #search-container {
            opacity: 0;
            visibility: hidden;
            transform: translateX(-50%) translateY(-20px);
        }

        #searchInput {
            background-color: transparent;
            border: none;
            color: #c9d1d9;
            outline: none;
            font-size: 16px; /* 修复 #3: iOS上小于16px的字体聚焦会缩放，调整字体大小 */
            padding: 0 8px;
            /* 修改：使其宽度可变 */
            flex-grow: 1;
            min-width: 80px;
        }
        
        /* 隐藏原生搜索框的清除按钮 */
        #searchInput::-webkit-search-cancel-button {
           -webkit-appearance: none;
        }

        #searchBtn {
            background-color: #2ecc71; /* 修改为绿色 */
            color: white;
            border: none;
            border-radius: 99px;
            padding: 6px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
            width: auto; /* 自动宽度以适应SVG */
            text-align: center;
            flex-shrink: 0; /* 防止按钮被压缩 */
            user-select: none;
            -webkit-user-select: none;
            display: flex; /* 用于SVG居中 */
            align-items: center;
            justify-content: center;
            /* 新增: 移除移动端点击高亮和选中状态 */
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }
        #searchBtn:hover {
            background-color: #2ea043;
        }
        
        /* 新增取消按钮样式 */
        #searchBtn.cancel-search {
            background-color: #FF1B47; /* 保持红色 */
        }
        #searchBtn.cancel-search:hover {
            background-color: #ff4d6d;
        }
        /* --- 修改 END: 搜索框样式 --- */


        /* --- 修改 START: 汉堡图标样式 --- */
        #sidebar-toggle-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: transparent; /* 去掉背景 */
            border: none;
            width: 46px;  /* 修改：使其成为正方形，与搜索框高度匹配 */
            height: 46px; /* 修改：与搜索框高度(8+30+8=46px)匹配 */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            padding: 0;
        }

        .hamburger-icon {
            width: 30px;  /* 修改：增大图标尺寸 */
            height: 24px; /* 修改：增大图标尺寸 */
            position: relative;
        }

        .hamburger-icon span {
            display: block;
            position: absolute;
            height: 4px; /* 修改：加粗线条 */
            width: 100%;
            background: #c9d1d9;
            border-radius: 2px;
            opacity: 1;
            left: 0;
            transform: rotate(0deg);
            transition: .25s ease-in-out;
        }

        /* Y position of the three stripes */
        .hamburger-icon span:nth-child(1) { top: 0px; }
        .hamburger-icon span:nth-child(2) { top: 10px; } /* 修改：调整位置 */
        .hamburger-icon span:nth-child(3) { top: 20px; } /* 修改：调整位置 */

        /* Rotate first bar */
        #sidebar-toggle-btn.open .hamburger-icon span:nth-child(1) {
            top: 10px; /* 修改：调整位置 */
            transform: rotate(135deg);
        }

        /* Hide middle bar */
        #sidebar-toggle-btn.open .hamburger-icon span:nth-child(2) {
            opacity: 0;
            left: -30px; /* 修改：匹配新宽度 */
        }

        /* Rotate last bar */
        #sidebar-toggle-btn.open .hamburger-icon span:nth-child(3) {
            top: 10px; /* 修改：调整位置 */
            transform: rotate(-135deg);
        }
        /* --- 修改 END: 汉堡图标样式 --- */


        /* --- 修复 START: 侧边栏半透明效果 --- */
        /* 侧边栏本身 (MODIFIED) */
        #config-sidebar {
            position: fixed;
            top: 0;
            right: 0;
            height: 100vh;
            width: 300px; /* 侧边栏宽度 */
            /* 修复：确保半透明和模糊效果生效 */
            background-color: rgba(49, 49, 49, 0.259); /* 使用更匹配主题的半透明色 */
            backdrop-filter: blur(10px); /* 增强模糊效果 */
            -webkit-backdrop-filter: blur(10px); /* 增加浏览器兼容性前缀 */
            transform: translateX(100%); /* 初始状态，完全隐藏 */
            transition: transform 0.3s ease-in-out;
            z-index: 99;
            padding: 20px;
            padding-top: 80px; /* 为汉堡按钮留出空间 */
            overflow-y: auto;
            box-sizing: border-box; /* 关键修复：确保 padding 不会增加总高度 */
        }
        /* --- 修复 END: 侧边栏半透明效果 --- */

        #config-sidebar.open {
            transform: translateX(0); /* 展开状态 */
        }
        
        /* --- START MODIFICATION 2: Sidebar adjustment visibility --- */
        /* When adjusting, make the sidebar container transparent but keep its layout space */
        body.adjusting-param #config-sidebar {
            background-color: transparent !important;
            border-left-color: transparent !important;
            backdrop-filter: none !important;
            box-shadow: none !important;
        }

        /* Hide all direct children within the config panel */
        body.adjusting-param #config-panel > * {
            opacity: 0;
            pointer-events: none;
            transition: opacity: 0.2s ease-in-out;
        }

        /* But, force the one being adjusted to be visible */
        body.adjusting-param #config-panel > .is-adjusting {
            opacity: 1;
            pointer-events: auto;
        }
        
        body.adjusting-param #sidebar-overlay {
            opacity: 0;
            pointer-events: none;
        }
        /* --- END MODIFICATION 2 --- */
        
        /* 侧边栏滚动条美化 (MODIFIED) */
        #config-sidebar::-webkit-scrollbar { width: 8px; }
        #config-sidebar::-webkit-scrollbar-track {
            background: transparent; border-radius: 4px;
        }
        #config-sidebar::-webkit-scrollbar-thumb {
            background: #444c56; border-radius: 4px;
        }
        #config-sidebar::-webkit-scrollbar-thumb:hover { background: #2ecc71; }


        /* 侧边栏背景遮罩 (MODIFIED) */
        #sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
            z-index: 98;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #sidebar-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        /* 配置面板样式 */
        #config-panel {
            background-color: transparent;
            border: none;
            padding: 0;
            border-radius: 0;
            font-size: 14px;
            color: #c9d1d9;
            backdrop-filter: none;
            box-shadow: none;
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            /* 修复: 增加侧边栏底部内边距 */
            padding-bottom: 120px; 
        }

        .config-item { display: flex; flex-direction: column; gap: 6px; }
        .config-item label { font-size: 12px; color: #8b949e; }
        
        .input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* --- 样式 START: 美化滑块 --- */
        .config-item input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px; /* 略微加高轨道 */
            background: #444c56; /* 默认轨道颜色 */
            outline: none;
            border-radius: 4px;
            flex-grow: 1;
        }

        .config-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; 
            appearance: none;
            width: 18px; 
            height: 18px;
            background: #1284FF; /* 手柄填充色 */
            cursor: pointer; 
            border-radius: 50%;
            border: 9px solid #1170D5; /* 加粗边框和新颜色 */
        }
        .config-item input[type="range"]::-moz-range-thumb {
            width: 18px; 
            height: 18px;
            background: #1284FF; /* 手柄填充色 */
            cursor: pointer; 
            border-radius: 50%;
            border: 9px solid #1170D5; /* 加粗边框和新颜色 */
        }
        /* --- 样式 END: 美化滑块 --- */
        
        /* NEW: 参数调节器容器样式 */
        .control-stack {
            background-color: #000000;
            padding: 10px 15px;
            border-radius: 12px;
            position: relative;
            z-index: 101; /* Ensure it's on top */
        }

        /* NEW: 参数值显示样式 */
        .value-display {
            width: 50px;
            text-align: right;
            font-size: 16px;
            color: #c9d1d9;
            flex-shrink: 0;
            font-family: "Microsoft YaHei UI Bold", "微软雅黑", sans-serif;
            font-weight: bold;
        }


        /* 标签输入框和颜色选择器的容器 */
        .tag-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        #tagNameInput, #graphTitleInput {
            background-color: rgba(30,30,30,0.8);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 6px 10px;
            color: #c9d1d9;
            outline: none;
            box-sizing: border-box;
            height: 34px;
            backdrop-filter: blur(5px);
            flex: 1;
            min-width: 50px;
            font-size: 14px;
        }
        
        #tagColorInput {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 34px;
            height: 34px;
            background-color: rgba(30,30,30,0.8);
            border: 1px solid #30363d;
            border-radius: 12px;
            cursor: pointer;
            padding: 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            backdrop-filter: blur(5px);
            transition: transform .12s ease, background-color .12s ease, box-shadow .12s ease;
            flex-shrink: 0;
        }
        #tagColorInput:hover {
            background-color: rgba(44,44,44,0.85);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.25);
        }
        #tagColorInput:active { transform: translateY(0); }
        #tagColorInput:focus-visible {
            outline: 2px solid #2ecc7133; /* MODIFIED COLOR */
            box-shadow: 0 0 0 3px #2ecc7122, 0 6px 16px rgba(0,0,0,0.25); /* MODIFIED COLOR */
        }
        #tagColorInput::-webkit-color-swatch-wrapper {
            padding: 4px;
            border-radius: 12px;
        }
        #tagColorInput::-webkit-color-swatch {
            border-radius: 8px;
            border: none;
        }
        #tagColorInput::-moz-color-swatch {
            border-radius: 8px;
            border: none;
        }

        /* --- 修复 START: 按钮文字居中 --- */
        #saveTagBtn, .data-btn, #togglePulseBtn, #toggleImageClipBtn, #toggleArrowBtn, #saveTitleBtn {
            background-color: #30363d;
            color: #ffffff;
            border: none;
            border-radius: 12px;
            padding: 0 12px; /* 调整内边距 */
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s, transform .12s ease;
            flex-shrink: 0;
            white-space: nowrap;
            height: 34px;
            /* 使用flex进行完美居中 */
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        /* --- 修复 END: 按钮文字居中 --- */

        #saveTagBtn, #saveTitleBtn {
            width: auto;
        }
        
        /* 新增: 脉冲动画按钮 */
        #togglePulseBtn, #toggleImageClipBtn, #toggleArrowBtn {
            flex: 1;
        }

        .data-actions .data-btn {
            flex: 1;
        }
        
        /* --- 代码修复 START: 分离保存按钮的悬停效果 --- */
        #saveTagBtn:hover, .data-btn:hover, #togglePulseBtn:hover, #toggleImageClipBtn:hover, #toggleArrowBtn:hover { background-color: #444c56; transform: translateY(-1px); }
        #saveTagBtn:active, .data-btn:active, #togglePulseBtn:active, #toggleImageClipBtn:active, #toggleArrowBtn:active, #saveTitleBtn:active { transform: translateY(0); }

        #saveTitleBtn.save { background-color: #2ecc71; }
        #saveTitleBtn.save:hover { background-color: #2ea043; transform: translateY(-1px); }
        #saveTitleBtn.cancel { background-color: #d13030; }
        #saveTitleBtn.cancel:hover { background-color: #e04444; transform: translateY(-1px); }
        /* --- 代码修复 END --- */
        
        #exportBtn {
            background-color: #2ecc71;
        }
        #exportBtn:hover {
            background-color: #2ea043;
        }
        #importBtn {
            background-color: #1385FF; /* 修改为蓝色 */
        }
        #importBtn:hover {
            background-color: #0f74e6; /* MODIFIED COLOR */
        }


        #tag-list {
            margin-top: 8px;
            max-height: 150px;
            overflow-y: auto;
            padding-right: 5px;
        }
        #tag-list::-webkit-scrollbar { width: 6px; }
        #tag-list::-webkit-scrollbar-track {
            background: transparent; border-radius: 3px;
        }
        #tag-list::-webkit-scrollbar-thumb {
            background: #444c56; border-radius: 3px;
        }
        #tag-list::-webkit-scrollbar-thumb:hover { background: #2ecc71; }

        .tag-item {
            display: flex;
            align-items: center;
            justify-content: space-between; /* This will push the button to the right */
            gap: 8px;
            font-size: 12px;
            padding: 6px 8px;
            border-radius: 8px;
            background-color: #161b22;
            margin-bottom: 6px;
            border: 1px solid #30363d;
        }
        .tag-color-swatch {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            border: 1px solid #30363d;
            flex-shrink: 0;
        }
        
        /* New style for the delete button */
        .tag-delete-btn {
            background-color: transparent;
            border: none;
            color: #8b949e;
            cursor: pointer;
            padding: 2px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, color 0.2s;
        }
        .tag-delete-btn:hover {
            background-color: #d13030;
            color: white;
        }

        #info-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(30, 30, 30, 0.8);
            /* 修改：移除边框 */
            border: none;
            padding: 8px;
            border-radius: 99px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mode-btn {
            background-color: transparent;
            color: #c9d1d9;
            border: none;
            border-radius: 99px;
            padding: 8px 20px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            /* 修复: 防止按钮文本被选中和出现点击高亮 */
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }
        
        .mode-btn.active {
            background-color: #1284FF; /* 修改为蓝色 */
            color: #ffffff;
        }
        
        .edit-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
            /* MODIFIED: Center the dialog on the cursor */
            transform: translate(-50%, -50%); 
            align-items: center;
            padding: 12px;
            background-color: rgba(30,30,30,0.8);
            border: 1px solid #30363d;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .edit-input, .image-url-input {
            width: 100%;
        }
        .edit-input, .image-url-input, .tag-selector, .tag-controls button {
            background-color: rgba(30,30,30,0.8);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 6px 10px;
            color: #c9d1d9;
            outline: none;
            box-sizing: border-box;
            font-size: 14px;
        }
        .edit-input { text-align: center; }

        .tag-controls {
            display: flex;
            gap: 5px;
            align-items: center;
            width: 100%;
        }

        /* --- 修复 START: 按钮文字居中 --- */
        #confirmBtn, #editNodeBtn, #deleteNodeBtn, #cancelBtn, .relation-edit-container button {
            color: white;
            border: none;
            border-radius: 10px;
            padding: 6px 10px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
            /* 使用flex进行完美居中 */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* --- 修复 END: 按钮文字居中 --- */

        #confirmBtn, #editNodeBtn {
            background-color: #2ecc71; /* 修改为蓝色 */
        }
        #deleteNodeBtn, #cancelBtn {
            background-color: #d13030;
        }
        #deleteNodeBtn:hover, #cancelBtn:hover { background-color: #e04444; }
        #confirmBtn:hover, #editNodeBtn:hover { background-color: #3b73b5; } /* MODIFIED COLOR */

        .relation-edit-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
            /* MODIFIED: Center the dialog on the cursor */
            transform: translate(-50%, -50%);
            align-items: center;
            padding: 12px;
            background-color: rgba(30,30,30,0.8);
            border: 1px solid #30363d;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .relation-edit-container input {
            background-color: rgba(30,30,30,0.8);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 6px 10px;
            color: #c9d1d9;
            outline: none;
            box-sizing: border-box;
            /* 新增：处理长文本溢出 */
            text-overflow: ellipsis;
        }
        .relation-edit-container button {
            background-color: #2ecc71; /* 修改为蓝色 */
        }
        .relation-edit-container button:hover { background-color: #3b73b5; } /* MODIFIED COLOR */

        /* 新增: 预览模式样式 */
        body.preview-mode #info-panel,
        body.preview-mode #search-container,
        body.preview-mode #sidebar-toggle-btn,
        body.preview-mode #config-sidebar,
        body.preview-mode #sidebar-overlay {
            display: none !important;
        }
        
        /* 新增: 页面内通知样式 */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #2ecc71;
            color: white;
            padding: 12px 24px;
            border-radius: 99px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, top 0.3s ease-in-out, visibility 0.3s ease-in-out;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .notification.show {
            opacity: 1;
            visibility: visible;
            top: 30px;
        }

        .notification.error {
            background-color: #d13030;
        }

        /* 新增: Powered by 样式 */
        .powered-by {
            text-align: center;
            font-size: 12px;
            color: #8b949e;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div id="graph-container">
        <canvas id="graphCanvas"></canvas>
    </div>

    <!-- 新增: 页面内通知 -->
    <div id="notification" class="notification"></div>

    <!-- 新增: 搜索框 -->
    <div id="search-container">
        <input type="text" id="searchInput" placeholder="搜索节点...">
        <button id="searchBtn">
             <svg id="magnifying-glass-svg" width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M11 19C15.4183 19 19 15.4183 19 11C19 6.58172 15.4183 3 11 3C6.58172 3 3 6.58172 3 11C3 15.4183 6.58172 19 11 19Z" stroke="currentColor" stroke-width="2"/>
                <path d="M21 21L16.65 16.65" stroke="currentColor" stroke-width="2"/>
            </svg>
        </button>
    </div>

    <input type="file" id="importFileInput" style="display: none;" accept=".json">

    <button id="sidebar-toggle-btn">
        <div class="hamburger-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </button>

    <div id="sidebar-overlay"></div>
    <div id="config-sidebar">
        <div id="config-panel">
            <h3 style="margin-top:0;">设置面板</h3>
            <div class="control-stack">
                <div class="config-item">
                    <label for="repulsionStrength">斥力强度</label>
                    <div class="input-group">
                        <input type="range" id="repulsionStrength" min="0" max="5" step="0.1" value="1">
                        <span id="repulsionStrengthValue" class="value-display">1</span>
                    </div>
                </div>
            </div>
            <div class="control-stack">
                <div class="config-item">
                    <label for="mouseAttraction">鼠标吸附力</label>
                    <div class="input-group">
                        <input type="range" id="mouseAttraction" min="0" max="1" step="0.01" value="0.05">
                        <span id="mouseAttractionValue" class="value-display">0.05</span>
                    </div>
                </div>
            </div>

            <div class="control-stack">
                <div class="config-item">
                    <label for="linkIncreaseRate">节点比率 (%)</label>
                    <div class="input-group">
                        <input type="range" id="linkIncreaseRate" min="0" max="100" value="5">
                        <span id="linkIncreaseRateValue" class="value-display">5</span>
                    </div>
                </div>
            </div>
            <div class="control-stack">
                <div class="config-item">
                    <label for="titleSize">标题大小</label>
                    <div class="input-group">
                        <input type="range" id="titleSize" min="5" max="30" step="1" value="10">
                        <span id="titleSizeValue" class="value-display">10</span>
                    </div>
                </div>
            </div>
             <div class="control-stack">
                <div class="config-item">
                    <label for="relationSize">关系文本大小</label>
                    <div class="input-group">
                        <input type="range" id="relationSize" min="5" max="25" step="1" value="10">
                        <span id="relationSizeValue" class="value-display">10</span>
                    </div>
                </div>
            </div>
            <div class="control-stack">
                <div class="config-item">
                    <label for="lineWidth">线段粗细</label>
                    <div class="input-group">
                        <input type="range" id="lineWidth" min="0.1" max="5" step="0.1" value="0.5">
                        <span id="lineWidthValue" class="value-display">0.5</span>
                    </div>
                </div>
            </div>
            <div class="control-stack">
                <div class="config-item">
                    <label for="maxLinkDistance">最大连线距离</label>
                    <div class="input-group">
                        <input type="range" id="maxLinkDistance" min="50" max="500" step="10" value="200">
                        <span id="maxLinkDistanceValue" class="value-display">200</span>
                    </div>
                </div>
            </div>
            <div class="control-stack">
                <div class="config-item">
                    <label for="imageNodeSize">图片节点大小</label>
                    <div class="input-group">
                        <input type="range" id="imageNodeSize" min="10" max="100" value="30">
                        <span id="imageNodeSizeValue" class="value-display">30</span>
                    </div>
                </div>
            </div>
            <!-- 修改：调整箭头控件位置 -->
            <div class="control-stack">
                <div class="config-item">
                    <label>关系箭头</label>
                    <div class="input-group">
                         <button id="toggleArrowBtn" class="data-btn">显示箭头: 开</button>
                    </div>
                </div>
            </div>
            <div class="control-stack">
                <div class="config-item">
                    <label for="arrowSize">箭头大小</label>
                    <div class="input-group">
                        <input type="range" id="arrowSize" min="2" max="20" step="1" value="8">
                        <span id="arrowSizeValue" class="value-display">8</span>
                    </div>
                </div>
            </div>
            <!-- 修改：调整动画控件位置 -->
            <div class="control-stack">
                <div class="config-item">
                    <label>动画效果</label>
                    <div class="input-group">
                         <button id="togglePulseBtn" class="data-btn">脉冲动画: 开</button>
                    </div>
                </div>
            </div>
            <div class="control-stack">
                <div class="config-item">
                    <label>图片节点样式</label>
                    <div class="input-group">
                         <button id="toggleImageClipBtn" class="data-btn">圆形裁剪: 开</button>
                    </div>
                </div>
            </div>
            <div class="config-item">
                <label>标签管理</label>
                <div class="tag-input-group">
                    <input type="text" id="tagNameInput" placeholder="输入标签名">
                    <input type="color" id="tagColorInput" value="#2ecc71">
                    <button id="saveTagBtn">保存</button>
                </div>
            </div>
            <div id="tag-list" class="config-item">
                <!-- Saved tags will appear here -->
            </div>
            <!-- 新增: 标题和数据管理 -->
            <div class="config-item">
                <label>数据管理</label>
                <div class="input-group">
                    <input type="text" id="graphTitleInput" placeholder="图谱标题">
                    <button id="saveTitleBtn">保存</button>
                </div>
            </div>
            <div class="config-item">
                <div class="input-group data-actions">
                    <button id="importBtn" class="data-btn">导入</button>
                    <button id="exportBtn" class="data-btn">导出</button>
                </div>
                 <!-- 新增: Powered by Sidera -->
                <div class="powered-by">Powered by Sidera</div>
            </div>

        </div>
    </div>
    
    <div id="info-panel">
        <button id="defaultModeBtn" class="mode-btn active">普通</button>
        <button id="drawModeBtn" class="mode-btn">牵线</button>
    </div>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const infoPanel = document.getElementById('info-panel');
        const body = document.body;

        const defaultModeBtn = document.getElementById('defaultModeBtn');
        const drawModeBtn = document.getElementById('drawModeBtn');
        
        // --- 新增: 获取搜索框元素 ---
        const searchInput = document.getElementById('searchInput');
        const searchBtn = document.getElementById('searchBtn');


        const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
        const configSidebar = document.getElementById('config-sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        
        const repulsionStrengthEl = document.getElementById('repulsionStrength');
        const repulsionStrengthValueEl = document.getElementById('repulsionStrengthValue');
        const linkIncreaseRateEl = document.getElementById('linkIncreaseRate');
        const linkIncreaseRateValueEl = document.getElementById('linkIncreaseRateValue');
        const titleSizeEl = document.getElementById('titleSize');
        const titleSizeValueEl = document.getElementById('titleSizeValue');
        const relationSizeEl = document.getElementById('relationSize');
        const relationSizeValueEl = document.getElementById('relationSizeValue');
        const lineWidthEl = document.getElementById('lineWidth');
        const lineWidthValueEl = document.getElementById('lineWidthValue');
        const maxLinkDistanceEl = document.getElementById('maxLinkDistance');
        const maxLinkDistanceValueEl = document.getElementById('maxLinkDistanceValue');
        const imageNodeSizeEl = document.getElementById('imageNodeSize');
        const imageNodeSizeValueEl = document.getElementById('imageNodeSizeValue');
        const mouseAttractionEl = document.getElementById('mouseAttraction');
        const mouseAttractionValueEl = document.getElementById('mouseAttractionValue');
        // 新增：获取脉冲动画按钮
        const togglePulseBtn = document.getElementById('togglePulseBtn');
        // 新增：获取图片裁剪按钮
        const toggleImageClipBtn = document.getElementById('toggleImageClipBtn');
        // 新增：获取箭头控件
        const toggleArrowBtn = document.getElementById('toggleArrowBtn');
        const arrowSizeEl = document.getElementById('arrowSize');
        const arrowSizeValueEl = document.getElementById('arrowSizeValue');


        const tagNameInput = document.getElementById('tagNameInput');
        const tagColorInput = document.getElementById('tagColorInput');
        const saveTagBtn = document.getElementById('saveTagBtn');
        const tagListContainer = document.getElementById('tag-list');

        const importBtn = document.getElementById('importBtn');
        const exportBtn = document.getElementById('exportBtn');
        const importFileInput = document.getElementById('importFileInput');

        // 新增: 获取标题相关元素
        const graphTitleInput = document.getElementById('graphTitleInput');
        const saveTitleBtn = document.getElementById('saveTitleBtn');
        
        // --- 新增: SVG 图标常量 ---
        const svgSearch = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 19C15.4183 19 19 15.4183 19 11C19 6.58172 15.4183 3 11 3C6.58172 3 3 6.58172 3 11C3 15.4183 6.58172 19 11 19Z" stroke="currentColor" stroke-width="2"/><path d="M21 21L16.65 16.65" stroke="currentColor" stroke-width="2"/></svg>`;
        const svgCancel = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 256 256"><g style="fill:currentColor" transform="scale(2.81 2.81)"><rect x="-9.61" y="35.97" width="109.22" height="18.05" transform="matrix(0.7071 -0.7071 0.7071 0.7071 -18.6396 44.9976)"/><rect x="35.97" y="-9.61" width="18.05" height="109.22" transform="matrix(0.7071 -0.7071 0.7071 0.7071 -18.6396 44.9996)"/></g></svg>`;
        const svgConfirmCheck = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 72 72"><path fill="currentColor" d="M57.658,12.643c1.854,1.201,2.384,3.678,1.183,5.532l-25.915,40c-0.682,1.051-1.815,1.723-3.064,1.814 C29.764,59.997,29.665,60,29.568,60c-1.146,0-2.241-0.491-3.003-1.358L13.514,43.807c-1.459-1.659-1.298-4.186,0.36-5.646 c1.662-1.46,4.188-1.296,5.646,0.361l9.563,10.87l23.043-35.567C53.329,11.971,55.806,11.442,57.658,12.643z"/></svg>`;
        const svgDelete = `<svg width="18" height="18" viewBox="0 0 15 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M12.41,5.58l-1.34,8c-0.0433,0.2368-0.2493,0.4091-0.49,0.41H4.42c-0.2407-0.0009-0.4467-0.1732-0.49-0.41l-1.34-8 C2.5458,5.3074,2.731,5.0506,3.0035,5.0064C3.0288,5.0023,3.0544,5.0002,3.08,5h8.83c0.2761-0.0036,0.5028,0.2174,0.5064,0.4935 C12.4168,5.5225,12.4146,5.5514,12.41,5.58z M13,3.5C13,3.7761,12.7761,4,12.5,4h-10C2.2239,4,2,3.7761,2,3.5S2.2239,3,2.5,3H5V1.5 C5,1.2239,5.2239,1,5.5,1h4C9.7761,1,10,1.2239,10,1.5V3h2.5C12.7761,3,13,3.2239,13,3.5z M9,3V2H6v1H9z"/></svg>`;
        const svgConfirmSave = `<svg fill="currentColor" width="18" height="18" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21,20V8.414a1,1,0,0,0-.293-.707L16.293,3.293A1,1,0,0,0,15.586,3H4A1,1,0,0,0,3,4V20a1,1,0,0,0,1,1H20A1,1,0,0,0,21,20ZM9,8h4a1,1,0,0,1,0,2H9A1,1,0,0,1,9,8Zm7,11H8V15a1,1,0,0,1,1-1h6a1,1,0,0,1,1,1Z"/></svg>`;

        let isPreviewMode = false;
        let width, height;
        let dpr = window.devicePixelRatio || 1;
        function resizeCanvas() {
            // logical CSS size
            dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
        
            // set CSS display size (so getBoundingClientRect returns CSS pixels)
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        
            // set backing store size (device pixels)
            canvas.width = Math.round(width * dpr);
            canvas.height = Math.round(height * dpr);
        
            // reset any transform and scale so 1 unit == 1 CSS pixel for drawing code
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const numNodes = 50;
        const baseNodeRadius = 5;
        // --- 参数设置 ---
        let repulsionStrength = parseFloat(repulsionStrengthEl.value);
        let linkIncreaseRate = parseFloat(linkIncreaseRateEl.value) / 100;
        let titleSize = parseInt(titleSizeEl.value);
        let relationSize = parseInt(relationSizeEl.value);
        let lineWidth = parseFloat(lineWidthEl.value);
        let maxLinkDistance = parseInt(maxLinkDistanceEl.value);
        let repulsionRadius = maxLinkDistance * 3;  // repulsion radius = 3x maxLinkDistance
        let imageNodeSize = parseInt(imageNodeSizeEl.value);
        let isPulseAnimationEnabled = true; // 新增：脉冲动画开关状态
        let isImageClippingEnabled = true; // 新增：图片裁剪开关状态
        let isArrowVisible = true; // 新增：箭头显示开关
        let arrowSize = parseInt(arrowSizeEl.value); // 新增：箭头大小
        
        const fixedNodeRepulsionMultiplier = 2; 
        const anchorNodeRepulsionMultiplier = 8;
        const linkParticleSpeed = 0.05;
        const linkStrength = 0.005;
        const friction = 0.95;
        const particleSpeedPixelsPerFrame = 10;
        const nodeGlowFadeRate = 0.05;
        const linkGlowFadeRate = 0.05;
        let mouseAttractionStrength = (typeof mouseAttractionEl !== 'undefined' && mouseAttractionEl) ? parseFloat(mouseAttractionEl.value) : 0.05; 
        let nextNodeId = 0; 

        // --- 代码修复: 增加 savedGraphTitle 用于状态管理 ---
        let graphTitle = '';
        let savedGraphTitle = '';

        let tags = [];
        let nodes = [];
        let links = [];
        
        // --- 新增: 搜索辉光效果和触控状态变量 ---
        let searchGlow = { alpha: 0, direction: 1 };
        let lastTouchDistance = null;
        let lastTap = 0;
        let longPressTimeout = null;
        let touchStartPos = null;
        let isZooming = false; // 修复 #4: 新增一个标志位，判断当前是否正在进行双指缩放


        // 初始化默认图谱
        function initializeDefaultGraph() {
            nodes.length = 0;
            links.length = 0;
            tags.length = 0;
            nextNodeId = 0;
            graphTitle = '';
            savedGraphTitle = ''; // 修复：初始化时重置
            graphTitleInput.value = '';


            for (let i = 0; i < numNodes; i++) {
                nodes.push({
                    id: nextNodeId++,
                    name: `节点 ${i + 1}`,
                    x: Math.random() * width,
                    y: Math.random() * height,
                    vx: 0,
                    vy: 0,
                    connectionCount: 0,
                    radius: baseNodeRadius,
                    isDragging: false,
                    glowAlpha: 0,
                    isNew: false,
                    isFixed: false,
                    isAnchor: false,
                    isHighlighted: false,
                    fixType: null, // 修复: 新增 fixType 属性
                    wobbleOffset: { x: 0, y: 0 },
                    tag: null,
                    imageUrl: null,
                    image: null,
                    isSearchResult: false, 
                    hyperlink: null 
                });
            }

            for (let i = 0; i < numNodes; i++) {
                for (let j = i + 1; j < numNodes; j++) {
                    if (Math.random() < 0.1) {
                        links.push({
                            source: nodes[i],
                            target: nodes[j],
                            relation: {
                                [nodes[i].id]: `关系 ${i}->${j}`,
                                [nodes[j].id]: null
                            },
                            pulse: null,
                            linkGlowAlpha: 0,
                            lastPulseTime: 0,
                            isHighlighted: false
                        });
                        nodes[i].connectionCount++;
                        nodes[j].connectionCount++;
                    }
                }
            }
            nodes.forEach(node => {
                node.radius = baseNodeRadius * (1 + node.connectionCount * linkIncreaseRate);
            });
            updateSaveTitleButtonUI(); // 修复：确保按钮状态被更新
        }
        
        let scale = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastPanMouseX = 0;
        let lastPanMouseY = 0;
        let mouse = { x: 0, y: 0, isDown: false, lastX: 0, lastY: 0 };
        let draggedNode = null;
        let hoverNode = null;
        let hoverLink = null;
        let lastHoveredNode = null;
        let hoverOriginalRadius = 0;
        let editingInput = null;
        let editingNode = null;
        let editingRelation = null;

        let currentMode = 'default';
        let drawSourceNode = null;
        let drawTargetNode = null;
        let drawLineGlowAlpha = 0;
        let cutLineStart = null;
        let isCutting = false;
        let glowDirection = 1;
        const wobbleIntensity = 1.0;
        
        let isShiftDragging = false;
        let dragStartPos = null;

        // --- 新增: 页面内通知函数 ---
        function showNotification(message, isError = false) {
            const notification = document.getElementById('notification');
            if (!notification) return;

            notification.textContent = message;
            notification.classList.toggle('error', isError);
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // --- 修改: 侧边栏交互逻辑 ---
        sidebarToggleBtn.addEventListener('click', () => {
            const isOpen = configSidebar.classList.toggle('open');
            sidebarOverlay.classList.toggle('open', isOpen);
            sidebarToggleBtn.classList.toggle('open', isOpen);
            document.body.classList.toggle('sidebar-open', isOpen);
        });

        sidebarOverlay.addEventListener('click', () => {
            configSidebar.classList.remove('open');
            sidebarOverlay.classList.remove('open');
            sidebarToggleBtn.classList.remove('open');
            document.body.classList.remove('sidebar-open');
        });
        
        // --- JS START: 滑块样式更新逻辑 ---
        function setupSliderListeners() {
            const sliders = document.querySelectorAll('input[type="range"]');
            
            sliders.forEach(slider => {
                const valueDisplay = document.getElementById(`${slider.id}Value`);
                const controlStack = slider.closest('.control-stack');

                // 用于更新滑块背景的函数
                const updateTrackBackground = () => {
                    if (!valueDisplay) return; // 安全检查
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    const val = parseFloat(slider.value);
                    const percentage = ((val - min) * 100) / (max - min);
                    const fillColor = '#1284FF'; // 填充颜色
                    const trackColor = '#444c56'; // 轨道默认颜色
                    slider.style.background = `linear-gradient(to right, ${fillColor} ${percentage}%, ${trackColor} ${percentage}%)`;
                };

                // 初始化滑块背景
                updateTrackBackground();

                slider.addEventListener('input', () => {
                    if (valueDisplay) valueDisplay.textContent = slider.value;
                    updateTrackBackground(); // 每次拖动都更新背景

                    // 更新全局变量
                    switch(slider.id) {
                        case 'repulsionStrength': repulsionStrength = parseFloat(slider.value); break;
                        case 'linkIncreaseRate': 
                            linkIncreaseRate = parseFloat(slider.value) / 100;
                            nodes.forEach(node => {
                                if (!node.imageUrl) {
                                   node.radius = baseNodeRadius * (1 + node.connectionCount * linkIncreaseRate);
                                }
                            });
                            break;
                        case 'titleSize': titleSize = parseInt(slider.value); break;
                        case 'relationSize': relationSize = parseInt(slider.value); break;
                        case 'lineWidth': lineWidth = parseFloat(slider.value); break;
                        case 'maxLinkDistance': maxLinkDistance = parseInt(slider.value); repulsionRadius = maxLinkDistance * 3; break;
                        case 'imageNodeSize':
                            imageNodeSize = parseInt(slider.value);
                             nodes.forEach(node => {
                                if (node.imageUrl) {
                                    node.radius = imageNodeSize;
                                }
                            });
                            break;
                        case 'arrowSize': arrowSize = parseInt(slider.value); break;
                        case 'mouseAttraction': mouseAttractionStrength = parseFloat(slider.value); break;
                    }
                });

                const startAdjust = () => {
                    body.classList.add('adjusting-param');
                    if (controlStack) controlStack.classList.add('is-adjusting');
                };
                const endAdjust = () => {
                    body.classList.remove('adjusting-param');
                    if (controlStack) controlStack.classList.remove('is-adjusting');
                };

                slider.addEventListener('mousedown', startAdjust);
                slider.addEventListener('touchstart', startAdjust, { passive: true });
                slider.addEventListener('mouseup', endAdjust);
                slider.addEventListener('touchend', endAdjust);
            });
        }
        setupSliderListeners();
        // Initialize mouse attraction display if present
        if (typeof mouseAttractionValueEl !== 'undefined' && mouseAttractionValueEl && typeof mouseAttractionEl !== 'undefined' && mouseAttractionEl) {
            mouseAttractionValueEl.textContent = mouseAttractionEl.value;
        }
        // --- JS END: 滑块样式更新逻辑 ---

        // --- 新增 START: 脉冲动画按钮逻辑 ---
        function updatePulseButtonUI() {
            if (isPulseAnimationEnabled) {
                togglePulseBtn.textContent = '脉冲动画: 开';
                togglePulseBtn.style.backgroundColor = '#2ecc71'; // 绿色代表开启
            } else {
                togglePulseBtn.textContent = '脉冲动画: 关';
                togglePulseBtn.style.backgroundColor = '#d13030'; // 红色代表关闭
            }
        }

        togglePulseBtn.addEventListener('click', () => {
            isPulseAnimationEnabled = !isPulseAnimationEnabled;
            updatePulseButtonUI();
        });
        // --- 新增 END: 脉冲动画按钮逻辑 ---
        
        // --- 新增 START: 图片裁剪按钮逻辑 ---
        function updateImageClipButtonUI() {
            if (isImageClippingEnabled) {
                toggleImageClipBtn.textContent = '圆形裁剪: 开';
                toggleImageClipBtn.style.backgroundColor = '#2ecc71'; // Green for On
            } else {
                toggleImageClipBtn.textContent = '圆形裁剪: 关';
                toggleImageClipBtn.style.backgroundColor = '#d13030'; // Red for Off
            }
        }

        toggleImageClipBtn.addEventListener('click', () => {
            isImageClippingEnabled = !isImageClippingEnabled;
            updateImageClipButtonUI();
        });
        // --- 新增 END: 图片裁剪按钮逻辑 ---

        // --- 新增 START: 箭头显示按钮逻辑 ---
        function updateArrowButtonUI() {
            if (isArrowVisible) {
                toggleArrowBtn.textContent = '显示箭头: 开';
                toggleArrowBtn.style.backgroundColor = '#2ecc71'; // Green for On
            } else {
                toggleArrowBtn.textContent = '显示箭头: 关';
                toggleArrowBtn.style.backgroundColor = '#d13030'; // Red for Off
            }
        }

        toggleArrowBtn.addEventListener('click', () => {
            isArrowVisible = !isArrowVisible;
            updateArrowButtonUI();
        });
        // --- 新增 END: 箭头显示按钮逻辑 ---

        // --- 代码修复 START: 更新标题保存按钮逻辑 ---
        function updateSaveTitleButtonUI() {
            const currentTitle = graphTitleInput.value.trim();
            if (currentTitle && currentTitle === savedGraphTitle) {
                // 已保存状态
                saveTitleBtn.textContent = '取消';
                saveTitleBtn.classList.add('cancel');
                saveTitleBtn.classList.remove('save');
            } else {
                // 未保存或已修改状态
                saveTitleBtn.textContent = '保存';
                saveTitleBtn.classList.add('save');
                saveTitleBtn.classList.remove('cancel');
            }
        }

        graphTitleInput.addEventListener('input', updateSaveTitleButtonUI);

        saveTitleBtn.addEventListener('click', () => {
            if (saveTitleBtn.classList.contains('cancel')) {
                // 取消操作
                graphTitle = '';
                savedGraphTitle = '';
                graphTitleInput.value = '';
                showNotification('标题已清除!');
            } else {
                // 保存操作
                const title = graphTitleInput.value.trim();
                if (!title) {
                    showNotification('标题不能为空!', true);
                    return;
                }
                graphTitle = title;
                savedGraphTitle = title;
                showNotification('标题已保存!');
            }
            updateSaveTitleButtonUI();
        });
        // --- 代码修复 END ---


        function updateTagListUI() {
            tagListContainer.innerHTML = '';
            tags.forEach(tag => {
                const tagItem = document.createElement('div');
                tagItem.className = 'tag-item';

                // Container for color swatch and name to keep them together on the left
                const tagDetails = document.createElement('div');
                tagDetails.style.display = 'flex';
                tagDetails.style.alignItems = 'center';
                tagDetails.style.gap = '8px';

                const colorSwatch = document.createElement('div');
                colorSwatch.className = 'tag-color-swatch';
                colorSwatch.style.backgroundColor = tag.color;

                const tagNameEl = document.createElement('span');
                tagNameEl.textContent = tag.name;

                tagDetails.appendChild(colorSwatch);
                tagDetails.appendChild(tagNameEl);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'tag-delete-btn';
                // A slightly thicker 'X' icon for better visibility
                deleteBtn.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18 6L6 18" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M6 6L18 18" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`; 
                
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent any other events from firing
                    const tagNameToDelete = tag.name;
                    const tagIndex = tags.findIndex(t => t.name === tagNameToDelete);
                    if (tagIndex > -1) {
                        tags.splice(tagIndex, 1);
                        
                        // Update all nodes that used this tag
                        nodes.forEach(node => {
                            if (node.tag === tagNameToDelete) {
                                node.tag = null;
                            }
                        });
                        
                        // Refresh the tag list in the UI
                        updateTagListUI();
                    }
                });

                tagItem.appendChild(tagDetails);
                tagItem.appendChild(deleteBtn);
                tagListContainer.appendChild(tagItem);
            });
        }

        saveTagBtn.addEventListener('click', () => {
            const name = tagNameInput.value.trim();
            const color = tagColorInput.value;
            if (name === '') return;
            const existingTag = tags.find(t => t.name === name);
            if (existingTag) {
                existingTag.color = color;
            } else {
                tags.push({ name, color });
            }
            tagNameInput.value = '';
            updateTagListUI();
        });

        function getTagColor(tagName) {
            if (!tagName) return '#c9d1d9';
            const tag = tags.find(t => t.name === tagName);
            return tag ? tag.color : '#c9d1d9';
        }

        // --- MODIFIED START: Updated editRelation function ---
        function editRelation(link, x, y) {
            if (editingRelation) return;
            editingRelation = link;

            const cleanUp = () => {
                if (!editingRelation) return;
                editingRelation.isEditing = false;
                editingRelation = null;
                const container = document.querySelector('.relation-edit-container');
                if (container) container.remove();
                document.removeEventListener('mousedown', handleClickOutside);
            };

            const handleClickOutside = (e) => {
                if (e.target.closest('.relation-edit-container')) return;
                cleanUp();
            };
            
            const container = document.createElement('div');
            container.className = 'relation-edit-container';
            
            // FIX: Stop click events from bubbling up to the canvas
            container.addEventListener('mousedown', (e) => e.stopPropagation());
            container.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });

            const placeholder1 = `${link.source.name} → ${link.target.name}`;
            const relation1Input = document.createElement('input');
            relation1Input.type = 'text';
            relation1Input.placeholder = placeholder1;
            relation1Input.title = placeholder1;
            relation1Input.value = link.relation[link.source.id] || '';
            container.appendChild(relation1Input);

            const placeholder2 = `${link.target.name} → ${link.source.name}`;
            const relation2Input = document.createElement('input');
            relation2Input.type = 'text';
            relation2Input.placeholder = placeholder2;
            relation2Input.title = placeholder2;
            relation2Input.value = link.relation[link.target.id] || '';
            container.appendChild(relation2Input);

            const confirmBtn = document.createElement('button');
            confirmBtn.innerHTML = svgConfirmCheck;
            container.appendChild(confirmBtn);

            confirmBtn.addEventListener('mousedown', (e) => { 
                e.preventDefault();
                link.relation[link.source.id] = relation1Input.value.trim() || null;
                link.relation[link.target.id] = relation2Input.value.trim() || null;
                cleanUp();
            });

            container.style.left = `${x}px`;
            container.style.top = `${y}px`;
            document.body.appendChild(container);

            // FIX: Delay attaching the outside click listener to prevent immediate closing on double-click
            setTimeout(() => {
                document.addEventListener('mousedown', handleClickOutside);
            }, 0);
        }
        // --- MODIFIED END ---

        // --- MODIFIED START: Updated editNode function ---
        function editNode(node, clientX, clientY) {
            if (editingInput) return;
            editingNode = node;
            
            const wasOriginallyFixed = node.isFixed;
            editingNode.isFixed = true;

            const cleanUp = (deleteNode = false) => {
                if (!editingInput) return;
                if (deleteNode || (node.isNew && input.value.trim() === '')) {
                     for (let i = links.length - 1; i >= 0; i--) {
                        if (links[i].source === node || links[i].target === node) {
                            links.splice(i, 1);
                        }
                    }
                    const nodeIndex = nodes.indexOf(node);
                    if (nodeIndex > -1) nodes.splice(nodeIndex, 1);
                } else {
                    node.name = input.value.trim() || `节点 ${node.id + 1}`;
                    node.tag = tagSelector.value === "" ? null : tagSelector.value;
                    node.hyperlink = hyperlinkInput.value.trim() || null;
                    const newImageUrl = imageInput.value.trim();
                    if (newImageUrl && newImageUrl !== node.imageUrl) {
                        node.imageUrl = newImageUrl;
                        node.image = new Image();
                        node.image.onload = () => {
                            node.radius = imageNodeSize;
                            node.originalWidth = node.image.naturalWidth;
                            node.originalHeight = node.image.naturalHeight;
                            hoverOriginalRadius = imageNodeSize;
                        };
                        node.image.onerror = () => {
                            console.error(`Failed to load image: ${newImageUrl}`);
                            node.imageUrl = null;
                            node.image = null;
                            node.radius = baseNodeRadius * (1 + node.connectionCount * linkIncreaseRate);
                        };
                        node.image.src = newImageUrl;
                    } else if (!newImageUrl && node.imageUrl) {
                        node.imageUrl = null;
                        node.image = null;
                        node.originalWidth = undefined;
                        node.originalHeight = undefined;
                        const newRadius = baseNodeRadius * (1 + node.connectionCount * linkIncreaseRate);
                        node.radius = newRadius;
                        if (node === hoverNode) {
                           hoverOriginalRadius = newRadius;
                        }
                    }
                    node.isNew = false;
                }
                editingInput.remove();
                editingInput = null;
                editingNode = null;

                node.isFixed = wasOriginallyFixed;
                if (!wasOriginallyFixed) {
                    node.vx = 0;
                    node.vy = 0;
                }
                document.removeEventListener('mousedown', handleClickOutside);
            };

            const handleClickOutside = (e) => {
                if (editingInput && !editingInput.contains(e.target)) {
                    cleanUp(false);
                }
            };
            
            const container = document.createElement('div');
            container.className = 'edit-container';
            
            // FIX: Stop click events from bubbling up to the canvas
            container.addEventListener('mousedown', (e) => e.stopPropagation());
            container.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'edit-input';
            input.placeholder = "节点名称";
            input.value = node.name;
            container.appendChild(input);

            const imageInput = document.createElement('input');
            imageInput.type = 'url';
            imageInput.className = 'image-url-input';
            imageInput.placeholder = "图片URL (可选)";
            imageInput.value = node.imageUrl || '';
            container.appendChild(imageInput);

            const hyperlinkInput = document.createElement('input');
            hyperlinkInput.type = 'url';
            hyperlinkInput.className = 'image-url-input';
            hyperlinkInput.placeholder = "超链接 (可选)";
            hyperlinkInput.value = node.hyperlink || '';
            container.appendChild(hyperlinkInput);

            const controlsContainer = document.createElement('div');
            controlsContainer.className = 'tag-controls';
            
            const tagSelector = document.createElement('select');
            tagSelector.className = 'tag-selector';
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "无标签";
            tagSelector.appendChild(defaultOption);
            tags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag.name;
                option.textContent = tag.name;
                if (node.tag === tag.name) option.selected = true;
                tagSelector.appendChild(option);
            });
            controlsContainer.appendChild(tagSelector);

            if (node.isNew) {
                const confirmBtn = document.createElement('button');
                confirmBtn.id = 'confirmBtn';
                confirmBtn.innerHTML = svgConfirmSave;
                controlsContainer.appendChild(confirmBtn);

                const cancelBtn = document.createElement('button');
                cancelBtn.id = 'cancelBtn';
                cancelBtn.innerHTML = svgCancel;
                controlsContainer.appendChild(cancelBtn);

                confirmBtn.addEventListener('mousedown', (e) => { e.preventDefault(); cleanUp(false); });
                cancelBtn.addEventListener('mousedown', (e) => { e.preventDefault(); cleanUp(true); });
                input.addEventListener('keydown', (keyEvent) => { if (keyEvent.key === 'Enter') cleanUp(false); });
                imageInput.addEventListener('keydown', (keyEvent) => { if (keyEvent.key === 'Enter') cleanUp(false); });
                hyperlinkInput.addEventListener('keydown', (keyEvent) => { if (keyEvent.key === 'Enter') cleanUp(false); });
            } else {
                const editBtn = document.createElement('button');
                editBtn.id = 'editNodeBtn';
                editBtn.innerHTML = svgConfirmCheck;
                controlsContainer.appendChild(editBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.id = 'deleteNodeBtn';
                deleteBtn.innerHTML = svgDelete;
                controlsContainer.appendChild(deleteBtn);

                editBtn.addEventListener('mousedown', (e) => { e.preventDefault(); cleanUp(false); });
                deleteBtn.addEventListener('mousedown', (e) => { e.preventDefault(); cleanUp(true); });
                input.addEventListener('keydown', (keyEvent) => { if (keyEvent.key === 'Enter') cleanUp(false); });
                imageInput.addEventListener('keydown', (keyEvent) => { if (keyEvent.key === 'Enter') cleanUp(false); });
                hyperlinkInput.addEventListener('keydown', (keyEvent) => { if (keyEvent.key === 'Enter') cleanUp(false); });
            }
            
            container.appendChild(controlsContainer);

            // FIX: Position dialog at the cursor's client coordinates
            const finalX = clientX !== undefined ? clientX : (node.x * scale + panX);
            const finalY = clientY !== undefined ? clientY : (node.y * scale + panY);
            container.style.left = `${finalX}px`;
            container.style.top = `${finalY}px`;

            document.body.appendChild(container);
            input.focus();
            input.select();
            editingInput = container;

            // FIX: Delay attaching the outside click listener to prevent immediate closing on double-click
            setTimeout(() => {
                document.addEventListener('mousedown', handleClickOutside);
            }, 0);
        }
        // --- MODIFIED END ---

        // --- 新增 START: 箭头绘制函数 ---
        function drawArrow(ctx, fromNode, toNode, size, color) {
            const headLength = size; // size will control the length
            const headWidth = size / 3; // making it more slender

            const dx = toNode.x - fromNode.x;
            const dy = toNode.y - fromNode.y;
            const angle = Math.atan2(dy, dx);
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Don't draw if nodes are on top of each other
            if (dist < toNode.radius) return;
            
            // Calculate the point on the circle of the target node
            // This is where the tip of the arrow will be
            const toX = toNode.x - (toNode.radius * Math.cos(angle));
            const toY = toNode.y - (toNode.radius * Math.sin(angle));

            ctx.save();
            ctx.fillStyle = color;

            ctx.translate(toX, toY);
            ctx.rotate(angle);
            
            // Draw a slender arrow head. The size is divided by scale to keep it 
            // constant regardless of zoom level, making it appear fixed-size.
            ctx.beginPath();
            ctx.moveTo(0, 0); // Tip of the arrow
            ctx.lineTo(-headLength / scale, -headWidth / scale);
            ctx.lineTo(-headLength / scale, headWidth / scale);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        // --- 新增 END: 箭头绘制函数 ---
        
        function draw() {
            ctx.clearRect(0, 0, width, height);
            const now = performance.now();

            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(scale, scale);

            // --- 修改 START: 调整绘制顺序 ---
            // 1. 先绘制基础的灰色连线
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = lineWidth / scale;
            links.forEach(link => {
                ctx.beginPath();
                ctx.moveTo(link.source.x, link.source.y);
                ctx.lineTo(link.target.x, link.target.y);
                ctx.stroke();
            });

            // 2. 再绘制连线的辉光效果，使其位于上层
            links.forEach(link => {
                if (link.linkGlowAlpha > 0) {
                    const glowColor = getTagColor(link.source.tag || link.target.tag);
                    ctx.save();
                    ctx.globalAlpha = link.linkGlowAlpha;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = glowColor;
                    ctx.lineWidth = lineWidth / scale;
                    const startNode = link.source === hoverNode ? link.source : link.target;
                    const endNode = link.source === hoverNode ? link.target : link.source;
                    const gradient = ctx.createLinearGradient(startNode.x, startNode.y, endNode.x, endNode.y);
                    gradient.addColorStop(0, glowColor);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.strokeStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(link.source.x, link.source.y);
                    ctx.lineTo(link.target.x, link.target.y);
                    ctx.stroke();
                    ctx.restore();
                }
            });
            // --- 修改 END: 调整绘制顺序 ---
            
            // --- 优化 START: 高性能脉冲动画绘制 ---
            links.forEach(link => {
                // 修改：增加 isPulseAnimationEnabled 判断
                if (isPulseAnimationEnabled && link.pulse) {
                    const progress = (now - link.pulse.startTime) / link.pulse.duration;
                    if (progress < 0 || progress > 1) {
                        return; // 脉冲已结束或尚未开始
                    }

                    const startNode = link.pulse.startNode;
                    const endNode = link.pulse.endNode;
                    const pulseColor = getTagColor(startNode.tag);

                    const dx = endNode.x - startNode.x;
                    const dy = endNode.y - startNode.y;

                    const headX = startNode.x + dx * progress;
                    const headY = startNode.y + dy * progress;

                    const tailLength = 0.2; // 尾迹长度（占总长度的百分比）
                    const tailProgress = Math.max(0, progress - tailLength);
                    const tailX = startNode.x + dx * tailProgress;
                    const tailY = startNode.y + dy * tailProgress;
                    
                    // 当脉冲接近终点时，使其淡出
                    const opacity = 1 - progress; 

                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.lineWidth = 3 / scale;
                    ctx.lineCap = 'round';

                    // 创建从透明到彩色的渐变来模拟彗星尾迹
                    const gradient = ctx.createLinearGradient(tailX, tailY, headX, headY);
                    const colorRGB = `${parseInt(pulseColor.slice(1,3), 16)}, ${parseInt(pulseColor.slice(3,5), 16)}, ${parseInt(pulseColor.slice(5,7), 16)}`;
                    gradient.addColorStop(0, `rgba(${colorRGB}, 0)`);
                    gradient.addColorStop(1, pulseColor);
                    
                    ctx.strokeStyle = gradient;
                    ctx.shadowBlur = 20; // 为尾迹添加辉光
                    ctx.shadowColor = pulseColor;

                    ctx.beginPath();
                    ctx.moveTo(tailX, tailY);
                    ctx.lineTo(headX, headY);
                    ctx.stroke();

                    // 绘制脉冲头部的亮点
                    ctx.beginPath();
                    ctx.arc(headX, headY, 1.5 / scale, 0, Math.PI * 2);
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 30; // 为头部添加更强的辉光
                    ctx.shadowColor = pulseColor;
                    ctx.fill();

                    ctx.restore();
                }
            });
            // --- 优化 END: 高性能脉冲动画绘制 ---
            
            // Logic for "Default" mode when hovering over a node
            if (currentMode === 'default' && hoverNode) {
                const connectedLinks = links.filter(l => l.source === hoverNode || l.target === hoverNode);

                connectedLinks.forEach(link => {
                    const midX = (link.source.x + link.target.x) / 2;
                    const midY = (link.source.y + link.target.y) / 2;
                    
                    let relationToShow = null;
                    let relationColor = '#c9d1d9';
                    let sourceForAngle, targetForAngle;

                    if (link.source === hoverNode) {
                        relationToShow = link.relation[link.source.id];
                        relationColor = getTagColor(link.source.tag);
                        sourceForAngle = link.source;
                        targetForAngle = link.target;
                    } else { 
                        relationToShow = link.relation[link.target.id];
                        relationColor = getTagColor(link.target.tag);
                        sourceForAngle = link.target;
                        targetForAngle = link.source;
                    }

                    if (relationToShow) {
                        let angle = Math.atan2(targetForAngle.y - sourceForAngle.y, targetForAngle.x - sourceForAngle.x);
                        if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                            angle += Math.PI;
                        }

                        ctx.save();
                        ctx.translate(midX, midY);
                        ctx.rotate(angle);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.font = `bold ${relationSize / scale}px Arial`;
                        ctx.fillStyle = relationColor;
                        ctx.fillText(relationToShow, 0, 0);
                        ctx.restore();
                    }
                });
            } 
            // Logic for "Draw" mode when hovering over a highlighted link
            else if (currentMode === 'draw' && hoverLink && hoverLink.isHighlighted) {
                 const midX = (hoverLink.source.x + hoverLink.target.x) / 2;
                 const midY = (hoverLink.source.y + hoverLink.target.y) / 2;
                 let angle = Math.atan2(hoverLink.target.y - hoverLink.source.y, hoverLink.target.x - hoverLink.source.x);
                 
                 const sourceRelation = hoverLink.relation[hoverLink.source.id];
                 const targetRelation = hoverLink.relation[hoverLink.target.id];
                 let sourceNode = hoverLink.source;
                 let targetNode = hoverLink.target;

                 if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                     angle += Math.PI;
                 }
                 ctx.save();
                 ctx.translate(midX, midY);
                 ctx.rotate(angle);
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.font = `bold ${relationSize / scale}px Arial`;

                 if (sourceRelation) {
                     ctx.fillStyle = getTagColor(sourceNode.tag);
                     ctx.fillText(`${sourceNode.name} → ${targetNode.name}: ${sourceRelation}`, 0, -8 / scale);
                 }
                 if (targetRelation) {
                     ctx.fillStyle = getTagColor(targetNode.tag);
                     ctx.fillText(`${sourceNode.name} ← ${targetNode.name}: ${targetRelation}`, 0, 8 / scale);
                 }
                 ctx.restore();
            }


            if (currentMode === 'draw' && drawSourceNode) {
                ctx.save();
                ctx.lineWidth = 4 / scale;
                ctx.lineCap = 'round';
                ctx.shadowBlur = 10;
                const drawColor = getTagColor(drawSourceNode.tag);
                ctx.shadowColor = `rgba(${parseInt(drawColor.slice(1,3), 16)}, ${parseInt(drawColor.slice(3,5), 16)}, ${parseInt(drawColor.slice(5,7), 16)}, ${drawLineGlowAlpha})`;
                const startX = drawSourceNode.x;
                const startY = drawSourceNode.y;
                let endX, endY;
                
                const canvasMouseX = (mouse.x - panX) / scale;
                const canvasMouseY = (mouse.y - panY) / scale;
                const targetNode = findNodeAt(canvasMouseX, canvasMouseY);

                if (targetNode && targetNode !== drawSourceNode) {
                    endX = targetNode.x;
                    endY = targetNode.y;
                } else {
                    endX = canvasMouseX;
                    endY = canvasMouseY;
                }

                ctx.strokeStyle = `rgba(180, 180, 180, 1)`;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                ctx.restore();
            }

            if (currentMode === 'draw' && isCutting && cutLineStart) {
                const currentMouseX = (mouse.x - panX) / scale;
                const currentMouseY = (mouse.y - panY) / scale;
                ctx.save();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = 5 / scale;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff0000';
                ctx.strokeStyle = '#ff0000';
                ctx.beginPath();
                ctx.moveTo(cutLineStart.x, cutLineStart.y);
                ctx.lineTo(currentMouseX, currentMouseY);
                ctx.stroke();
                ctx.restore();
            }

            links.forEach(link => {
                if (link.isHighlighted) {
                    ctx.save();
                    ctx.lineWidth = 3 / scale;
                    ctx.lineCap = 'round';
                    ctx.strokeStyle = '#ffdd00';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffdd00';
                    ctx.beginPath();
                    ctx.moveTo(link.source.x, link.source.y);
                    ctx.lineTo(link.target.x, link.target.y);
                    ctx.stroke();
                    ctx.restore();
                }
            });

            // --- 新增 START: 绘制箭头 ---
            if (isArrowVisible) {
                links.forEach(link => {
                    // Only draw arrow if a relation text exists for that direction
                    if (link.relation[link.source.id]) {
                        const arrowColor = getTagColor(link.source.tag) || '#c9d1d9';
                        drawArrow(ctx, link.source, link.target, arrowSize, arrowColor);
                    }
                    if (link.relation[link.target.id]) {
                        const arrowColor = getTagColor(link.target.tag) || '#c9d1d9';
                        drawArrow(ctx, link.target, link.source, arrowSize, arrowColor);
                    }
                });
            }
            // --- 新增 END: 绘制箭头 ---

            // --- 修改 START: 分开绘制标题和节点以控制层级 ---
            // 3. 绘制节点标题 (带阴影)
            nodes.forEach(node => {
                const drawX = node.x;
                const drawY = node.y;

                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 4 / scale;
                ctx.fillStyle = '#c9d1d9';
                ctx.font = `${titleSize / scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(node.name, drawX, drawY - node.radius - 5 / scale);
                ctx.restore();
            });

            // 4. 绘制节点本身 (最上层)
            nodes.forEach(node => {
                const drawX = node.x;
                const drawY = node.y;

                if (node.isSearchResult) {
                    ctx.save();
                    ctx.globalAlpha = searchGlow.alpha;
                    ctx.lineWidth = 3 / scale; 
                    ctx.strokeStyle = '#ffdd00';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffdd00';
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, node.radius + 5 / scale, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }


                if (node.image && node.image.complete) {
                     // --- 修复 START: 保持图片原始比例绘制 ---
                    const maxDim = node.radius * 2;
                    const originalWidth = node.originalWidth || node.image.naturalWidth;
                    const originalHeight = node.originalHeight || node.image.naturalHeight;
                    
                    let newWidth, newHeight;
                    if (originalWidth > originalHeight) {
                        newWidth = maxDim;
                        newHeight = (maxDim / originalWidth) * originalHeight;
                    } else {
                        newHeight = maxDim;
                        newWidth = (maxDim / originalHeight) * originalWidth;
                    }

                    if (isImageClippingEnabled) {
                        const clipRadius = node.radius;
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(drawX, drawY, clipRadius, 0, Math.PI * 2, true);
                        ctx.clip();
                        ctx.drawImage(node.image, drawX - newWidth / 2, drawY - newHeight / 2, newWidth, newHeight);
                        ctx.restore();
                        
                        // Draw border
                        ctx.beginPath();
                        ctx.arc(drawX, drawY, clipRadius, 0, Math.PI * 2, true);
                        ctx.strokeStyle = getTagColor(node.tag); 
                        ctx.lineWidth = 2 / scale;
                        ctx.stroke();
                    } else {
                        ctx.drawImage(node.image, drawX - newWidth / 2, drawY - newHeight / 2, newWidth, newHeight);
                    }
                     // --- 修复 END ---
                } else {
                    let nodeColor = getTagColor(node.tag);
                    if (node.glowAlpha > 0) {
                        ctx.save();
                        ctx.shadowBlur = node.glowAlpha * 10;
                        ctx.shadowColor = nodeColor;
                        ctx.beginPath();
                        ctx.arc(drawX, drawY, node.radius, 0, Math.PI * 2);
                        ctx.fillStyle = nodeColor;
                        ctx.fill();
                        ctx.restore();
                    }
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, node.radius, 0, Math.PI * 2);
                    ctx.fillStyle = nodeColor;
                    ctx.fill();
                }
            });
            // --- 修改 END ---
            
            ctx.restore();
        }

        
        function findHoveredLink(x, y) {
            if (currentMode === 'draw') {
                 for (const link of links) {
                    if (!link.isHighlighted) continue;
                    
                    const p1 = link.source;
                    const p2 = link.target;
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const lenSq = dx * dx + dy * dy;
                    if (lenSq === 0) continue;
                    const t = ((x - p1.x) * dx + (y - p1.y) * dy) / lenSq;
                    const projectionT = Math.max(0, Math.min(1, t));
                    const projectionX = p1.x + projectionT * dx;
                    const projectionY = p1.y + projectionT * dy;
                    const dist = Math.sqrt(Math.pow(x - projectionX, 2) + Math.pow(y - projectionY, 2));

                    if (dist < 10 / scale) {
                        return link;
                    }
                }
            }
            return null;
        }

        function update() {
            const now = performance.now();

            searchGlow.alpha += searchGlow.direction * 0.03;
            if (searchGlow.alpha > 1 || searchGlow.alpha < 0.2) {
                searchGlow.direction *= -1;
                searchGlow.alpha = Math.max(0.2, Math.min(1, searchGlow.alpha));
            }

            if (currentMode === 'draw' && (drawSourceNode || hoverNode)) {
                drawLineGlowAlpha += glowDirection * 0.02;
                if (drawLineGlowAlpha > 1 || drawLineGlowAlpha < 0) {
                    glowDirection *= -1;
                    drawLineGlowAlpha = Math.max(0, Math.min(1, drawLineGlowAlpha));
                }
            } else {
                drawLineGlowAlpha = 0;
            }
            
            nodes.forEach(node => {
                node.wobbleOffset.x = 0;
                node.wobbleOffset.y = 0;
            });

            if (currentMode === 'default' || currentMode === 'draw') {
                const pulseDuration = 300; 
                links.forEach(link => {
                    const isLinkHovered = (link.source === hoverNode || link.target === hoverNode);

                    if (isLinkHovered && now - link.lastPulseTime > 1000) {
                        if (isPulseAnimationEnabled) {
                            link.pulse = {
                                startTime: now,
                                duration: pulseDuration,
                                startNode: link.source === hoverNode ? link.source : link.target,
                                endNode: link.source === hoverNode ? link.target : link.source
                            };
                        }
                        if (hoverNode) hoverNode.glowAlpha = 1; 
                        link.linkGlowAlpha = 1; 
                        link.lastPulseTime = now;
                    }

                    if (link.pulse && now - link.pulse.startTime > link.pulse.duration) {
                        link.pulse = null;
                    }
                });

                nodes.forEach(node => {
                    if (node.glowAlpha > 0) { node.glowAlpha -= 0.05; if (node.glowAlpha < 0) node.glowAlpha = 0; }
                });
                links.forEach(link => {
                    if (link.linkGlowAlpha > 0) { link.linkGlowAlpha -= 0.05; if (link.linkGlowAlpha < 0) link.linkGlowAlpha = 0; }
                });
            } else {
                links.forEach(link => { link.pulse = null; link.isHighlighted = false; link.linkGlowAlpha = 0; });
                nodes.forEach(node => { node.glowAlpha = 0; });
            }
            
            const canvasMouseX = (mouse.x - panX) / scale;
            const canvasMouseY = (mouse.y - panY) / scale;
            let newHoverNode = findNodeAt(canvasMouseX, canvasMouseY);
            
            hoverLink = findHoveredLink(canvasMouseX, canvasMouseY);


            if (newHoverNode && newHoverNode !== hoverNode) {
                if (hoverNode) hoverNode.radius = hoverOriginalRadius;
                hoverNode = newHoverNode;
                hoverOriginalRadius = newHoverNode.radius;
                newHoverNode.radius = hoverOriginalRadius * 1.5;
                if (currentMode === 'default' || currentMode === 'draw') canvas.style.cursor = 'pointer';
            } else if (!newHoverNode && hoverNode) {
                hoverNode.radius = hoverOriginalRadius;
                hoverNode = null;
                if (currentMode === 'default') canvas.style.cursor = 'grab';
            }
            lastHoveredNode = newHoverNode;

            nodes.forEach(node => {
                if (node.isDragging) return;

                nodes.forEach(otherNode => {
                    if (node !== otherNode) {
                        const dx = node.x - otherNode.x;
                        const dy = node.y - otherNode.y;

                        if (Math.abs(dx) > repulsionRadius || Math.abs(dy) > repulsionRadius) {
                            return; 
                        }

                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0 && distance < repulsionRadius) {
                            const physicalRadiusNode = (node === hoverNode) ? hoverOriginalRadius : node.radius;
                            const physicalRadiusOtherNode = (otherNode === hoverNode) ? hoverOriginalRadius : otherNode.radius;
                            
                            let forceMultiplier = 1;
                            if (node.isAnchor) {
                                forceMultiplier = anchorNodeRepulsionMultiplier;
                            } else if (node.isFixed) {
                                forceMultiplier = fixedNodeRepulsionMultiplier;
                            }
                            
                            const forceScale = (repulsionRadius - distance) / repulsionRadius;
                            const repulsionForce = repulsionStrength * (physicalRadiusNode + physicalRadiusOtherNode) * forceMultiplier / distance;
                            
                            node.vx += repulsionForce * dx / distance * forceScale;
                            node.vy += repulsionForce * dy / distance * forceScale;
                        }
                    }
                });
                
                if (!node.isFixed) {
                    links.forEach(link => {
                        if (link.source === node || link.target === node) {
                            const otherNode = link.source === node ? link.target : link.source;
                            const dx = otherNode.x - node.x;
                            const dy = otherNode.y - node.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance > 0) {
                                const force = linkStrength * (distance - maxLinkDistance);
                                node.vx += force * dx / distance;
                                node.vy += force * dy / distance;
                            }
                        }
                    });
                }
                
                if (node === hoverNode) {
                    const dx = canvasMouseX - node.x;
                    const dy = canvasMouseY - node.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 10 / scale) {
                        const force = mouseAttractionStrength * distance;
                        node.vx += force * dx / distance;
                        node.vy += force * dy / distance;
                    }
                }

                node.vx *= friction; node.vy *= friction;
                if (!node.isFixed) { 
                    node.x += node.vx;
                    node.y += node.vy;
                }
                
            });

            draw();
            requestAnimationFrame(update);
        }

        // --- 代码修复 START ---
        function setMode(newMode) {
            if (currentMode === newMode) {
                return;
            }
            currentMode = newMode;
            [defaultModeBtn, drawModeBtn].forEach(btn => btn.classList.remove('active'));
            
            if (currentMode === 'default') {
                defaultModeBtn.classList.add('active');
                canvas.style.cursor = 'grab';
                
                // 当从“牵线模式”切换回“普通模式”时，我们需要重置所有与牵线模式相关的状态。
                
                // 1. 遍历所有节点，取消任何被设置为“锚点”的节点。
                // “锚点”是在牵线模式下通过双击创建的，它们是固定的并且会高亮其连接。
                nodes.forEach(node => {
                    // 我们通过检查 `isAnchor` 属性来识别这些节点。
                    if (node.isAnchor) {
                        node.isAnchor = false;
                        node.isFixed = false;       // 取消其固定状态
                        node.vx = 0;               // 重置速度以防止弹飞
                        node.vy = 0;               // 重置速度以防止弹飞
                        node.fixType = null;       // 清除其特殊的固定类型
                        node.isHighlighted = false; // 取消其高亮状态
                    }
                });

                // 2. 遍历所有连线，确保取消所有连线的高亮显示。
                links.forEach(link => {
                    link.isHighlighted = false;
                });

            } else if (currentMode === 'draw') {
                drawModeBtn.classList.add('active');
                canvas.style.cursor = 'crosshair';
            }
            
            // 每次切换模式后，都重置与绘制相关的临时变量，以避免旧状态干扰新模式。
            drawSourceNode = null;
            cutLineStart = null;
            isCutting = false;
        }
        // --- 代码修复 END ---

        // --- MODIFIED START: Updated createNewNode function ---
        function createNewNode(x, y, clientX, clientY) {
            const newNode = {
                id: nextNodeId++,
                name: '',
                x: x, y: y,
                vx: 0, vy: 0,
                connectionCount: 0,
                radius: baseNodeRadius,
                isDragging: false,
                glowAlpha: 0,
                isNew: true,
                isFixed: false, 
                isAnchor: false,
                isHighlighted: false,
                fixType: null, // 修复: 新增 fixType 属性
                wobbleOffset: { x: 0, y: 0 },
                tag: null,
                imageUrl: null,
                image: null,
                isSearchResult: false,
                hyperlink: null
            };
            nodes.push(newNode);
            editNode(newNode, clientX, clientY);
        }
        // --- MODIFIED END ---
        
        defaultModeBtn.addEventListener('click', () => setMode('default'));
        drawModeBtn.addEventListener('click', () => setMode('draw'));
        
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        let shiftKeyPressed = false;
        document.addEventListener('keydown', (e) => {
    // Ignore key bindings when typing in input/textarea/contenteditable
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
        return;
    }
            if (e.key === 'Shift') {
                shiftKeyPressed = true;
            }
            // 添加键盘切换模式功能
            if (e.key === 'a' || e.key === 'A') {
                e.preventDefault(); // 防止页面滚动
                setMode('default');
            } else if (e.key === 'd' || e.key === 'D') {
                e.preventDefault(); // 防止页面滚动
                setMode('draw');
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') {
                shiftKeyPressed = false;
            }
        });

        function findNodeAt(graphX, graphY) {
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                const dx = node.x - graphX;
                const dy = node.y - graphY;
                if (Math.sqrt(dx * dx + dy * dy) < node.radius * 1.5) {
                    return node;
                }
            }
            return null;
        }

        function findLinkAt(x, y, linkSet) {
            let closestLink = null;
            let minDistanceSq = Math.pow(10 / scale, 2); 

            for (const link of linkSet) {
                const p1 = link.source;
                const p2 = link.target;
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const lenSq = dx * dx + dy * dy;

                if (lenSq === 0) continue;

                const t = ((x - p1.x) * dx + (y - p1.y) * dy) / lenSq;
                const projectionT = Math.max(0, Math.min(1, t)); 
                const projectionX = p1.x + projectionT * dx;
                const projectionY = p1.y + projectionT * dy;
                const distSq = Math.pow(x - projectionX, 2) + Math.pow(y - projectionY, 2);

                if (distSq < minDistanceSq) {
                    minDistanceSq = distSq;
                    closestLink = link;
                }
            }
            return closestLink;
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            
            isPanning = false;
            
            const graphMouseX = (mouse.x - panX) / scale;
            const graphMouseY = (mouse.y - panY) / scale;

            const clickedNode = findNodeAt(graphMouseX, graphMouseY);
            
            if (shiftKeyPressed && clickedNode && clickedNode.fixType !== 'anchor') {
                isShiftDragging = true;
                draggedNode = clickedNode;
                draggedNode.isDragging = true;
                draggedNode.vx = 0; 
                draggedNode.vy = 0;
                dragStartPos = { x: e.clientX, y: e.clientY };
                return;
            }

            if (shiftKeyPressed && !clickedNode) {
                isPanning = true;
                lastPanMouseX = e.clientX;
                lastPanMouseY = e.clientY;
                canvas.style.cursor = 'grabbing';
                return;
            }
            
            if (currentMode === 'draw') {
                if (e.button === 2) { 
                    isCutting = true;
                    cutLineStart = { x: graphMouseX, y: graphMouseY };
                    return; 
                }
                
                if (drawSourceNode) { 
                    if (clickedNode && clickedNode !== drawSourceNode) {
                        const linkExists = links.some(link =>
                            (link.source === drawSourceNode && link.target === clickedNode) ||
                            (link.source === clickedNode && link.target === drawSourceNode)
                        );
                        if (!linkExists) {
                            links.push({
                                source: drawSourceNode,
                                target: clickedNode,
                                relation: { [drawSourceNode.id]: null, [clickedNode.id]: null },
                                pulse: null, linkGlowAlpha: 0, lastPulseTime: 0, isHighlighted: false
                            });
                            drawSourceNode.connectionCount++;
                            clickedNode.connectionCount++;
                            drawSourceNode.radius = drawSourceNode.imageUrl ? imageNodeSize : baseNodeRadius * (1 + drawSourceNode.connectionCount * linkIncreaseRate);
                            clickedNode.radius = clickedNode.imageUrl ? imageNodeSize : baseNodeRadius * (1 + clickedNode.connectionCount * linkIncreaseRate);
                        }
                        isShiftDragging = false;
                        draggedNode = null;
                        dragStartPos = null;
                        drawSourceNode = null; 
                    } else if (clickedNode && clickedNode === drawSourceNode) {
                        isShiftDragging = false;
                        draggedNode = null;
                        dragStartPos = null;
                        drawSourceNode = null;
                    } else if (!clickedNode) {
                        isPanning = true;
                        lastPanMouseX = e.clientX;
                        lastPanMouseY = e.clientY;
                        canvas.style.cursor = 'grab';
                    }
                } else { 
                    if (clickedNode) {
                        drawSourceNode = clickedNode; 
                    } else {
                        isPanning = true;
                        lastPanMouseX = e.clientX;
                        lastPanMouseY = e.clientY;
                        canvas.style.cursor = 'grab';
                    }
                }
                return; 
            } 
            
            if (e.button !== 0) return;
            mouse.isDown = true;
            if (clickedNode) {
                draggedNode = clickedNode;
                draggedNode.isDragging = true;
                draggedNode.vx = 0;
                draggedNode.vy = 0;
                nodes.splice(nodes.indexOf(draggedNode), 1);
                nodes.push(draggedNode);
                canvas.style.cursor = 'grabbing';
            } else {
                isPanning = true;
                lastPanMouseX = e.clientX;
                lastPanMouseY = e.clientY;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;

            const graphMouseX = (mouse.x - panX) / scale;
            const graphMouseY = (mouse.y - panY) / scale;

            if (isPanning) {
                const dx = e.clientX - lastPanMouseX;
                const dy = e.clientY - lastPanMouseY;
                panX += dx;
                panY += dy;
                lastPanMouseX = e.clientX;
                lastPanMouseY = e.clientY;
                canvas.style.cursor = 'grabbing';
            } else if (draggedNode) {
                draggedNode.x = graphMouseX;
                draggedNode.y = graphMouseY;
            } else if (drawSourceNode) {
                // The line drawing is handled in the main draw() loop
            } else if (currentMode === 'draw' && isCutting && cutLineStart) {
                links.forEach(link => {
                    const p1 = link.source;
                    const p2 = link.target;
                    const q1 = cutLineStart;
                    const q2 = { x: graphMouseX, y: graphMouseY };
                    
                    const s1_x = p2.x - p1.x;
                    const s1_y = p2.y - p1.y;
                    const s2_x = q2.x - q1.x;
                    const s2_y = q2.y - q1.y;
                    const det = (-s2_x * s1_y + s1_x * s2_y);
                    if (Math.abs(det) < 1e-6) {
                        link.isHighlighted = false;
                        return;
                    }
                    const s = (-s1_y * (p1.x - q1.x) + s1_x * (p1.y - q1.y)) / det;
                    const t = ( s2_x * (p1.y - q1.y) - s2_y * (p1.x - q1.x)) / det;

                    link.isHighlighted = (s >= 0 && s <= 1 && t >= 0 && t <= 1);
                });
            } else {
                const hoveredNode = findNodeAt(graphMouseX, graphMouseY);
                const hoveredLink = findHoveredLink(graphMouseX, graphMouseY);

                if (hoveredLink) {
                    canvas.style.cursor = 'pointer';
                } else if (currentMode === 'draw') {
                    if (hoveredNode) {
                        canvas.style.cursor = 'pointer';
                        hoveredNode.glowAlpha = 1;
                    } else {
                        canvas.style.cursor = 'crosshair';
                    }
                } else if (currentMode === 'default') {
                    if (hoveredNode) {
                        canvas.style.cursor = 'pointer';
                    } else if (!shiftKeyPressed) {
                        canvas.style.cursor = 'grab';
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isShiftDragging) {
                const dist = Math.hypot(e.clientX - dragStartPos.x, e.clientY - dragStartPos.y);
                
                if (dist < 5) { 
                    draggedNode.isFixed = !draggedNode.isFixed;
                    if(draggedNode.isFixed) {
                        draggedNode.fixType = 'shift';
                    } else {
                        draggedNode.fixType = null;
                    }
                } else { 
                    draggedNode.isFixed = true;
                    draggedNode.fixType = 'shift';
                }

                if (draggedNode.isFixed) {
                    draggedNode.vx = 0;
                    draggedNode.vy = 0;
                }
                
                draggedNode.isDragging = false;
                draggedNode = null;
                isShiftDragging = false;
                dragStartPos = null;
                return; 
            }

            mouse.isDown = false;
            
            if (draggedNode) { draggedNode.isDragging = false; draggedNode = null; }
            
            if (currentMode === 'draw' && isCutting && cutLineStart && e.button === 2) {
                for (let i = links.length - 1; i >= 0; i--) {
                    const link = links[i];
                    if (link.isHighlighted) { 
                        links[i].source.connectionCount--;
                        links[i].target.connectionCount--;
                        links[i].source.radius = links[i].source.imageUrl ? imageNodeSize : baseNodeRadius * (1 + links[i].source.connectionCount * linkIncreaseRate);
                        links[i].target.radius = links[i].target.imageUrl ? imageNodeSize : baseNodeRadius * (1 + links[i].target.connectionCount * linkIncreaseRate);
                        links.splice(i, 1);
                    }
                }
                cutLineStart = null;
                isCutting = false;
                links.forEach(link => link.isHighlighted = false);
            }
            
            isPanning = false;
            
            if (currentMode === 'draw' && !drawSourceNode) {
                 canvas.style.cursor = 'crosshair';
            } else if (currentMode === 'default') {
                 canvas.style.cursor = 'grab';
            }
        });

        canvas.addEventListener('mouseleave', () => {
            mouse.isDown = false;
            isPanning = false;
            if (draggedNode) { draggedNode.isDragging = false; draggedNode = null; }
            if (isCutting) {
                isCutting = false;
                cutLineStart = null;
                links.forEach(l => l.isHighlighted = false);
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = 1.1;
            const oldScale = scale;
            const rect = canvas.getBoundingClientRect();

            const mouseX = (e.clientX - rect.left - panX) / oldScale;
            const mouseY = (e.clientY - rect.top - panY) / oldScale;

            if (e.deltaY < 0) { scale *= zoomFactor; } else { scale /= zoomFactor; }
            scale = Math.max(0.1, Math.min(scale, 5));
            panX = -(mouseX * scale) + (e.clientX - rect.left);
            panY = -(mouseY * scale) + (e.clientY - rect.top);
        });

        // --- 修复 START: dblclick 事件处理 ---
        function handleDoubleClick(e, customGraphX, customGraphY) {
             if (editingInput || editingRelation) return;
             
             let graphMouseX, graphMouseY;
             let clientX, clientY;

             if (customGraphX !== undefined && customGraphY !== undefined) {
                graphMouseX = customGraphX;
                graphMouseY = customGraphY;
                clientX = e.clientX; 
                clientY = e.clientY; 
             } else {
                const rect = canvas.getBoundingClientRect();
                graphMouseX = (e.clientX - rect.left - panX) / scale;
                graphMouseY = (e.clientY - rect.top - panY) / scale;
                clientX = e.clientX;
                clientY = e.clientY;
             }

            const clickedNode = findNodeAt(graphMouseX, graphMouseY);
            
            if (isPreviewMode) {
                return;
            }
            
            const targetLinks = (currentMode === 'draw') ? links.filter(l => l.isHighlighted) : links;
            const clickedLink = findLinkAt(graphMouseX, graphMouseY, targetLinks);

            if (currentMode === 'default') {
                if (clickedNode) {
                    editNode(clickedNode, clientX, clientY);
                } else if (clickedLink) {
                    editRelation(clickedLink, clientX, clientY);
                } else {
                    createNewNode(graphMouseX, graphMouseY, clientX, clientY);
                }
            } else if (currentMode === 'draw') {
                if (clickedNode) {
                    if (clickedNode.isAnchor && clickedNode.fixType === 'anchor') {
                        // It's an anchor, so un-anchor it.
                        clickedNode.isAnchor = false;
                        clickedNode.isFixed = false;
                        clickedNode.fixType = null;
                        clickedNode.isHighlighted = false;
                        // 修复: 重置速度防止弹飞
                        clickedNode.vx = 0;
                        clickedNode.vy = 0;

                        links.forEach(link => {
                            if (link.source === clickedNode || link.target === clickedNode) {
                                const otherNode = link.source === clickedNode ? link.target : link.source;
                                if (!otherNode.isAnchor) {
                                    link.isHighlighted = false;
                                }
                            }
                        });
                    } else {
                        // It's either not an anchor, or it's a shift-fixed node.
                        // In either case, we want to make it an anchor.
                        clickedNode.isAnchor = true;
                        clickedNode.isFixed = true;
                        clickedNode.fixType = 'anchor'; // Override previous fixType
                        clickedNode.isHighlighted = true;
                        
                        links.forEach(link => {
                            if (link.source === clickedNode || link.target === clickedNode) {
                                link.isHighlighted = true;
                            }
                        });
                    }
                } else if (clickedLink) {
                    editRelation(clickedLink, clientX, clientY);
                } else {
                    drawSourceNode = null;
                }
            }
        }
        // --- 修复 END ---
        
        canvas.addEventListener('dblclick', (e) => {
            handleDoubleClick(e);
        });

        canvas.addEventListener('click', (e) => {
            if (!isPreviewMode) return;
            
            setTimeout(() => {
                if (isPanning || draggedNode) return;
    
                const rect = canvas.getBoundingClientRect();
                const graphMouseX = (e.clientX - rect.left - panX) / scale;
                const graphMouseY = (e.clientY - rect.top - panY) / scale;
                const clickedNode = findNodeAt(graphMouseX, graphMouseY);
    
                if (clickedNode && clickedNode.hyperlink) {
                     try {
                        const url = new URL(clickedNode.hyperlink);
                        if (url.protocol === "http:" || url.protocol === "https:") {
                            window.open(clickedNode.hyperlink, '_blank');
                        }
                    } catch (err) {
                        console.error("Invalid hyperlink format:", clickedNode.hyperlink);
                    }
                }
            }, 200);
        });
        
        function exportData() {
            const serializableNodes = nodes.map(node => {
                const { image, ...rest } = node; 
                return rest;
            });

            const serializableLinks = links.map(link => ({
                sourceId: link.source.id,
                targetId: link.target.id,
                relation: link.relation,
            }));

            const settings = {
                repulsionStrength: parseFloat(repulsionStrengthEl.value),
                linkIncreaseRate: parseFloat(linkIncreaseRateEl.value),
                titleSize: parseInt(titleSizeEl.value),
                relationSize: parseInt(relationSizeEl.value),
                lineWidth: parseFloat(lineWidthEl.value),
                maxLinkDistance: parseInt(maxLinkDistanceEl.value),
                imageNodeSize: parseInt(imageNodeSizeEl.value),
                isPulseAnimationEnabled: isPulseAnimationEnabled,
                isImageClippingEnabled: isImageClippingEnabled,
                isArrowVisible: isArrowVisible,
                arrowSize: parseInt(arrowSizeEl.value)
            };

            // MODIFIED: Save the logical center instead of absolute pan values
            const viewState = {
                scale: scale,
                centerX: (width / 2 - panX) / scale,
                centerY: (height / 2 - panY) / scale
            };

            const dataToExport = {
                graphTitle: savedGraphTitle, // 修复: 导出已保存的标题
                nodes: serializableNodes,
                links: serializableLinks,
                tags: tags,
                nextNodeId: nextNodeId,
                settings: settings,
                viewState: viewState
            };

            const jsonString = JSON.stringify(dataToExport, null, 2); 
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            // 新增: 使用保存的标题作为文件名
            const fileName = savedGraphTitle.trim() ? `${savedGraphTitle.trim()}.json` : 'graph-data.json';
            a.download = fileName;
            document.body.appendChild(a);
            a.click();

            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadData(jsonString) {
            try {
                const data = JSON.parse(jsonString);

                if (!data.nodes || !data.links || !data.tags || !Array.isArray(data.nodes) || !Array.isArray(data.links) || !Array.isArray(data.tags)) {
                    throw new Error('无效的数据格式。');
                }
                
                nodes.length = 0;
                links.length = 0;
                tags.length = 0;

                // --- 代码修复 START: 更新标题加载逻辑 ---
                graphTitle = data.graphTitle || '';
                savedGraphTitle = data.graphTitle || '';
                graphTitleInput.value = graphTitle;
                updateSaveTitleButtonUI();
                // --- 代码修复 END ---


                tags.push(...data.tags);

                data.nodes.forEach(nodeData => {
                    // 修复: 确保新属性存在
                    const newNode = { ...nodeData, image: null, isSearchResult: false, fixType: nodeData.fixType || null };
                    if (newNode.imageUrl) {
                        newNode.image = new Image();
                        newNode.image.onload = () => {
                            newNode.radius = imageNodeSize;
                            newNode.originalWidth = newNode.image.naturalWidth;
                            newNode.originalHeight = newNode.image.naturalHeight;
                        };
                        newNode.image.onerror = () => {
                            console.error(`无法加载图片: ${newNode.imageUrl}`);
                            newNode.imageUrl = null;
                            newNode.image = null;
                            newNode.radius = baseNodeRadius * (1 + newNode.connectionCount * linkIncreaseRate);
                        };
                        newNode.image.src = newNode.imageUrl;
                    }
                    nodes.push(newNode);
                });

                const nodeMap = new Map(nodes.map(n => [n.id, n]));

                data.links.forEach(linkData => {
                    const sourceNode = nodeMap.get(linkData.sourceId);
                    const targetNode = nodeMap.get(linkData.targetId);

                    if (sourceNode && targetNode) {
                        links.push({
                            source: sourceNode,
                            target: targetNode,
                            relation: linkData.relation,
                            pulse: null,
                            linkGlowAlpha: 0,
                            lastPulseTime: 0,
                            // 修复: 根据加载的节点状态恢复高亮
                            isHighlighted: sourceNode.isAnchor || targetNode.isAnchor
                        });
                    } else {
                        console.warn(`无法找到连线对应的节点: sourceId=${linkData.sourceId}, targetId=${linkData.targetId}`);
                    }
                });
                
                nextNodeId = data.nextNodeId || (nodes.length > 0 ? Math.max(...nodes.map(n => n.id)) + 1 : 0);
                
                if (data.settings) {
                    const settings = data.settings;
                    repulsionStrengthEl.value = settings.repulsionStrength ?? 1;
                    linkIncreaseRateEl.value = settings.linkIncreaseRate ?? 5;
                    titleSizeEl.value = settings.titleSize ?? 10;
                    relationSizeEl.value = settings.relationSize ?? 10;
                    lineWidthEl.value = settings.lineWidth ?? 0.5;
                    maxLinkDistanceEl.value = settings.maxLinkDistance ?? 200;
                    imageNodeSizeEl.value = settings.imageNodeSize ?? 30;
                    isPulseAnimationEnabled = settings.isPulseAnimationEnabled ?? true;
                    isImageClippingEnabled = settings.isImageClippingEnabled ?? true;
                    isArrowVisible = settings.isArrowVisible ?? true;
                    arrowSizeEl.value = settings.arrowSize ?? 8;

                    document.querySelectorAll('input[type="range"]').forEach(slider => {
                        slider.dispatchEvent(new Event('input', { bubbles: true }));
                    });
                    
                    updatePulseButtonUI();
                    updateImageClipButtonUI(); 
                    updateArrowButtonUI();
                }

                // MODIFIED: Recalculate pan based on the new window size and the saved logical center
                if (data.viewState) {
                    scale = data.viewState.scale ?? 1;
                    if (data.viewState.centerX !== undefined && data.viewState.centerY !== undefined) {
                        // New method: center based on logical coordinates
                        const centerX = data.viewState.centerX;
                        const centerY = data.viewState.centerY;
                        panX = (width / 2) - (centerX * scale);
                        panY = (height / 2) - (centerY * scale);
                    } else if (data.viewState.panX !== undefined) {
                        // Old method (for backward compatibility)
                        panX = data.viewState.panX;
                        panY = data.viewState.panY;
                    }
                } else {
                    panX = 0;
                    panY = 0;
                    scale = 1;
                }


                updateTagListUI();
                showNotification('数据导入成功！');

            } catch (error) {
                console.error('导入数据失败:', error);
                showNotification(`导入数据失败: ${error.message}`, true);
                initializeDefaultGraph();
            }
        }
        
        async function loadDataFromUrl(url) {
            try {
                const response = await fetch(url, { mode: 'cors' });
                if (!response.ok) {
                    throw new Error(`网络响应错误: ${response.statusText}`);
                }
                const jsonString = await response.text();
                loadData(jsonString); 
            } catch (error) {
                console.error('从URL加载数据失败:', error);
                showNotification(`从URL加载数据失败，即将加载默认图谱。`, true);
                initializeDefaultGraph(); 
            }
        }
        
        exportBtn.addEventListener('click', exportData);
        
        importBtn.addEventListener('click', () => {
            importFileInput.click();
        });

        importFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                loadData(content);
            };
            reader.onerror = (e) => {
                console.error("读取文件出错", e);
                showNotification("读取文件时发生错误。", true);
            };
            reader.readAsText(file);

            event.target.value = null;
        });

        searchBtn.addEventListener('click', () => {
            if (searchBtn.classList.contains('cancel-search')) {
                searchInput.value = '';
                nodes.forEach(node => node.isSearchResult = false);
                searchBtn.classList.remove('cancel-search');
                searchBtn.innerHTML = svgSearch;
            } else {
                const searchTerm = searchInput.value.trim().toLowerCase();
                if (searchTerm === '') {
                    nodes.forEach(node => node.isSearchResult = false);
                    return;
                }
                let foundResult = false;
                nodes.forEach(node => {
                    const isMatch = node.name.toLowerCase().includes(searchTerm);
                    node.isSearchResult = isMatch;
                    if (isMatch) {
                        foundResult = true;
                    }
                });

                if (foundResult) {
                    searchBtn.classList.add('cancel-search');
                    searchBtn.innerHTML = svgCancel;
                }
            }
        });

        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                searchBtn.click();
            }
        });

        searchInput.addEventListener('input', () => {
            if (searchInput.value.trim() === '') {
                nodes.forEach(node => node.isSearchResult = false);
                searchBtn.classList.remove('cancel-search');
                searchBtn.innerHTML = svgSearch;
            }
        });

        function getTouchDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // --- MODIFIED START: Updated touchstart listener ---
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touches = e.touches;
            const rect = canvas.getBoundingClientRect();

            if (touches.length >= 2) {
                isZooming = true;
                isPanning = false;
                if (draggedNode) draggedNode.isDragging = false;
                draggedNode = null;
                clearTimeout(longPressTimeout);
                longPressTimeout = null;
                lastTouchDistance = getTouchDistance(touches[0], touches[1]);
                return;
            }

            if (touches.length === 1) {
                const touch = touches[0];
                mouse.x = touch.clientX - rect.left;
                mouse.y = touch.clientY - rect.top;
                const graphMouseX = (mouse.x - panX) / scale;
                const graphMouseY = (mouse.y - panY) / scale;
                touchStartPos = { x: touch.clientX, y: touch.clientY, time: Date.now() };

                const now = new Date().getTime();
                if (now - lastTap < 300) {
                    clearTimeout(longPressTimeout);
                    longPressTimeout = null;
                    // FIX: Create a fake event object with client coordinates for handleDoubleClick
                    const fakeEvent = { clientX: touch.clientX, clientY: touch.clientY };
                    handleDoubleClick(fakeEvent, graphMouseX, graphMouseY);
                    lastTap = 0;
                    return;
                }
                lastTap = now;
                
                const tappedNode = findNodeAt(graphMouseX, graphMouseY);

                if (currentMode === 'draw') {
                    if (tappedNode) {
                        drawSourceNode = tappedNode;
                    } else {
                        isPanning = true;
                        lastPanMouseX = touch.clientX;
                        lastPanMouseY = touch.clientY;
                        longPressTimeout = setTimeout(() => {
                           isPanning = false; 
                           if (isZooming) return;
                           isCutting = true;
                           cutLineStart = { x: graphMouseX, y: graphMouseY };
                           longPressTimeout = null;
                           if (window.navigator && window.navigator.vibrate) {
                               window.navigator.vibrate(50);
                           }
                        }, 500);
                    }
                } else { 
                    if (tappedNode) {
                        draggedNode = tappedNode;
                        draggedNode.isDragging = true;
                        draggedNode.vx = 0; 
                        draggedNode.vy = 0;
                    } else {
                        isPanning = true;
                        lastPanMouseX = touch.clientX;
                        lastPanMouseY = touch.clientY;
                    }
                }
            }
        }, { passive: false });
        // --- MODIFIED END ---

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touches = e.touches;
            const rect = canvas.getBoundingClientRect();

            if (touches.length === 1 && touchStartPos) {
                const touch = touches[0];
                const dist = Math.hypot(touch.clientX - touchStartPos.x, touch.clientY - touchStartPos.y);
                if (dist > 10) { 
                    if(longPressTimeout) {
                        clearTimeout(longPressTimeout);
                        longPressTimeout = null;
                    }
                    lastTap = 0;
                    touchStartPos = null;
                }
            }
            
            if (touches.length >= 2) {
                isZooming = true;
                const currentDist = getTouchDistance(touches[0], touches[1]);
                if (lastTouchDistance) {
                    const zoomFactor = currentDist / lastTouchDistance;
                    const midX = (touches[0].clientX + touches[1].clientX) / 2;
                    const midY = (touches[0].clientY + touches[1].clientY) / 2;

                    const oldScale = scale;
                    const mouseX = (midX - rect.left - panX) / oldScale;
                    const mouseY = (midY - rect.top - panY) / oldScale;
                    
                    scale *= zoomFactor;
                    scale = Math.max(0.1, Math.min(scale, 5));

                    panX = -(mouseX * scale) + (midX - rect.left);
                    panY = -(mouseY * scale) + (midY - rect.top);
                }
                lastTouchDistance = currentDist;
                return;
            }

            if (touches.length === 1) {
                const touch = touches[0];
                mouse.x = touch.clientX - rect.left;
                mouse.y = touch.clientY - rect.top;
                
                if (draggedNode || drawSourceNode) {
                    const graphMouseX = (mouse.x - panX) / scale;
                    const graphMouseY = (mouse.y - panY) / scale;
                    if (draggedNode) {
                        draggedNode.x = graphMouseX;
                        draggedNode.y = graphMouseY;
                    }
                } else if (isPanning) { 
                    const dx = touch.clientX - lastPanMouseX;
                    const dy = touch.clientY - lastPanMouseY;
                    panX += dx;
                    panY += dy;
                    lastPanMouseX = touch.clientX;
                    lastPanMouseY = touch.clientY;
                } else if (isCutting && cutLineStart) {
                    const graphMouseX = (mouse.x - panX) / scale;
                    const graphMouseY = (mouse.y - panY) / scale;
                    links.forEach(link => {
                        const p1 = link.source;
                        const p2 = link.target;
                        const q1 = cutLineStart;
                        const q2 = { x: graphMouseX, y: graphMouseY };
                        
                        const s1_x = p2.x - p1.x;
                        const s1_y = p2.y - p1.y;
                        const s2_x = q2.x - q1.x;
                        const s2_y = q2.y - q1.y;
                        const det = (-s2_x * s1_y + s1_x * s2_y);
                        if (Math.abs(det) < 1e-6) {
                            link.isHighlighted = false;
                            return;
                        }
                        const s = (-s1_y * (p1.x - q1.x) + s1_x * (p1.y - q1.y)) / det;
                        const t = ( s2_x * (p1.y - q1.y) - s2_y * (p1.x - q1.x)) / det;

                        link.isHighlighted = (s >= 0 && s <= 1 && t >= 0 && t <= 1);
                    });
                }
            }
        }, { passive: false });
        
        const handleTouchEnd = (e) => {
            e.preventDefault();

            if (isPreviewMode && touchStartPos) {
                const timeElapsed = Date.now() - touchStartPos.time;
                const touch = e.changedTouches[0];
                const dist = Math.hypot(touch.clientX - touchStartPos.x, touch.clientY - touchStartPos.y);

                if (timeElapsed < 250 && dist < 10) {
                    const rect = canvas.getBoundingClientRect();
                    const graphMouseX = (touch.clientX - rect.left - panX) / scale;
                    const graphMouseY = (touch.clientY - rect.top - panY) / scale;
                    const tappedNode = findNodeAt(graphMouseX, graphMouseY);

                    if (tappedNode && tappedNode.hyperlink) {
                        try {
                            const url = new URL(tappedNode.hyperlink);
                            if (url.protocol === "http:" || url.protocol === "https:") {
                                const a = document.createElement('a');
                                a.href = tappedNode.hyperlink;
                                a.target = '_blank';
                                a.rel = 'noopener noreferrer';
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);

                                clearTimeout(longPressTimeout); longPressTimeout = null;
                                if (draggedNode) { draggedNode.isDragging = false; draggedNode = null; }
                                isPanning = false; lastTouchDistance = null; touchStartPos = null;
                                return;
                            }
                        } catch (err) {
                            console.error("Invalid hyperlink format:", tappedNode.hyperlink);
                        }
                    }
                }
            }
            
            clearTimeout(longPressTimeout);
            longPressTimeout = null;
            
            if (e.touches.length < 2) {
                isZooming = false;
            }
            
            const rect = canvas.getBoundingClientRect();
            const touch = e.changedTouches[0];
            
            if (touch) {
                mouse.x = touch.clientX - rect.left;
                mouse.y = touch.clientY - rect.top;
                const graphMouseX = (mouse.x - panX) / scale;
                const graphMouseY = (mouse.y - panY) / scale;
    
                if (currentMode === 'draw' && drawSourceNode) {
                    const targetNode = findNodeAt(graphMouseX, graphMouseY);
                    if (targetNode && targetNode !== drawSourceNode) {
                         const linkExists = links.some(link =>
                            (link.source === drawSourceNode && link.target === targetNode) ||
                            (link.source === targetNode && link.target === drawSourceNode)
                        );
                        if (!linkExists) {
                            links.push({
                                source: drawSourceNode, target: targetNode,
                                relation: { [drawSourceNode.id]: null, [targetNode.id]: null },
                                pulse: null, linkGlowAlpha: 0, lastPulseTime: 0, isHighlighted: false
                            });
                            drawSourceNode.connectionCount++; targetNode.connectionCount++;
                            drawSourceNode.radius = drawSourceNode.imageUrl ? imageNodeSize : baseNodeRadius * (1 + drawSourceNode.connectionCount * linkIncreaseRate);
                            targetNode.radius = targetNode.imageUrl ? imageNodeSize : baseNodeRadius * (1 + targetNode.connectionCount * linkIncreaseRate);
                        }
                    }
                }
    
                if (currentMode === 'draw' && isCutting) {
                     for (let i = links.length - 1; i >= 0; i--) {
                        const link = links[i];
                        if (link.isHighlighted) { 
                            link.source.connectionCount--;
                            link.target.connectionCount--;
                            link.source.radius = link.source.imageUrl ? imageNodeSize : baseNodeRadius * (1 + link.source.connectionCount * linkIncreaseRate);
                            link.target.radius = link.target.imageUrl ? imageNodeSize : baseNodeRadius * (1 + link.target.connectionCount * linkIncreaseRate);
                            links.splice(i, 1);
                        }
                    }
                    links.forEach(link => link.isHighlighted = false);
                }
            }

            if (draggedNode) { draggedNode.isDragging = false; draggedNode = null; }
            if (drawSourceNode) { drawSourceNode = null; }
            if (isCutting) { isCutting = false; cutLineStart = null; }
            isPanning = false;
            lastTouchDistance = null;
            touchStartPos = null;

            if (e.touches.length === 1) {
                const remainingTouch = e.touches[0];
                isPanning = true;
                lastPanMouseX = remainingTouch.clientX;
                lastPanMouseY = remainingTouch.clientY;
            }
        };

        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('touchcancel', handleTouchEnd);

    window.onload = async function() {
        const urlParams = new URLSearchParams(window.location.search);
        isPreviewMode = urlParams.has('preview');

        if (isPreviewMode) {
            document.body.classList.add('preview-mode');
        }

        updatePulseButtonUI();
        updateImageClipButtonUI();
        updateArrowButtonUI(); 
        updateSaveTitleButtonUI(); // 修复：确保页面加载时按钮状态正确

        const dataUrl = urlParams.get('dataUrl');

        if (dataUrl) {
            await loadDataFromUrl(dataUrl);
        } else {
            initializeDefaultGraph();
        }
        
        update();
    };

</script>
</body>
</html>